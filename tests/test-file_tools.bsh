. "$(dirname ${BASH_SOURCE[0]})/testlib.sh"
. "$(dirname ${BASH_SOURCE[0]})/test_utils.bsh"

VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
. "${VSI_COMMON_DIR}/linux/file_tools.bsh"
. "${VSI_COMMON_DIR}/linux/time_tools.bsh"

begin_test "Find and use available fd in bash 3.2"
(
  set -eu

  if [[ ${OSTYPE} = darwin* ]]; then
    DELAY=1
  else
    DELAY=0.1
  fi

  # Make a pipe
  mkfifo "${TRASHDIR}/pipe1"
  mkfifo "${TRASHDIR}/pipe2"

  #Open the pipe
  fifobuffer="${TRASHDIR}/pipe1" open_fd
  fd1="${fd}"

  fifobuffer="${TRASHDIR}/pipe2" open_fd
  fd2="${fd}"

  [ "${fd2}" -gt "${fd1}" ]

  # Write to the pipe
  printf 'a b  c\t\n\nd\n\n\n' >&${fd1}

  # Bash subshell substitution drop trailing newlines "by design"
  [ "$(timeout "${DELAY}" cat - <&${fd1})" = $'a b  c\t\n\nd' ]

  # Test scenario where newlines would be preserved
  printf 'a b  c\t\n\nd\n\n\n' >&${fd2}
  lines=()
  ans=($'a b  c\t' "" "d" "" "")
  for x in $(seq 5); do
    IFS='' read -u "${fd2}" -t "${DELAY}" -r line
    lines+=("${line}")
  done
  check_a lines "${ans[@]}"

  # This should timeout
  not read -u "${fd2}" -t "${DELAY}" -r line

  # close and cleanup
  close_fd "${fd1}"
  echo "ok">&"${fd2}"
  close_fd "${fd2}"

  #These should be closed now
  not_s "echo fail >&${fd1}"
  not_s "echo fail >&${fd2}"
)
end_test