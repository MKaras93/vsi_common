
. "$(dirname ${BASH_SOURCE[0]})/testlib.sh"

VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
. "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
. "${VSI_COMMON_DIR}/linux/just_functions.bsh"
. "${VSI_COMMON_DIR}/linux/elements.bsh"

setup()
{
  compose_file='version: "3.2"
services:
  nb:
    image: blah
    volumes:
      - /tmp:/mnt
      - test:/opt
  foo:
    image: bar
    volumes:
  bar:
    image: foo
volumes:
  test:'

  compose_file_hay="version: '3.2'
services:
  test_hay:
    image: alpine
    command: sh -c 'echo horse'"

  compose_file_sleep="version: '3.2'
services:
  test_sleepy:
    image: alpine
    command: sleep 100"

  track_touched_files
}

begin_test "Test DOCKER var"
(
  set -eu
  DRYRUN=echo
  DOCKER="DoCkEr"
  [ "$(Docker run test)" = "DoCkEr run --rm test" ]
)
end_test

begin_test "Test NVIDIA_DOCKER var"
(
  set -eu
  DRYRUN=echo
  NVIDIA_DOCKER="NvIdIa-DoCkEr"
  [ "$(Nvidia-docker run test)" = "NvIdIa-DoCkEr run --rm test" ]
)
end_test

begin_test "is_dir_and_not_exist"
(
  set -eu
  not is_dir_and_not_exist qwertyuiop
  not is_dir_and_not_exist /
  is_dir_and_not_exist "$(mktemp -d -u)"
)
end_test

command -v "${DOCKER}" >&/dev/null || skip_next_test
begin_test "container get label"
(
  set -eu

  check_skip

  "${DOCKER}" create -l t1=15 -l "TEST=THIS=t h  a   t" -l blank --name test-docker-function alpine

  [ "$(container_get_label test-docker-function t1)" = "15" ]
  [ "$(container_get_label test-docker-function TEST)" = "THIS=t h  a   t" ]
  [ "$(container_get_label test-docker-function blank)" = "" ]
  [ "$(container_get_label test-docker-function none)" = "" ]

  "${DOCKER}" rm test-docker-function
)
end_test

(command -v "${DOCKER}" >&/dev/null && command -v jq >&/dev/null) || skip_next_test
begin_test "container has label"
(
  set -eu

  check_skip

  "${DOCKER}" create -l t1=15 -l "TEST=THIS=t h  a   t" -l blank --name test-docker-function alpine

  container_has_label test-docker-function t1
  container_has_label test-docker-function TEST
  container_has_label test-docker-function blank
  not container_has_label test-docker-function none

  "${DOCKER}" rm test-docker-function
)
end_test

begin_test "docker_premkdir"
(
  set -eu
  temp_dir="${TRASHDIR}/pmd"
  mkdir -p "${temp_dir}"
  cd "${temp_dir}"

  docker_premkdir "${temp_dir}"
  docker_premkdir internal_dir
  [ ! -e internal_dir ]

  touch "${temp_dir}/premkfile"
  docker_premkdir "${temp_dir}/premkfile"
  [ ! -d "${temp_dir}/premkfile" ]
  [ -e "${temp_dir}/premkfile" ]

  [ ! -d "${temp_dir}/premkdir" ]
  docker_premkdir "${temp_dir}/premkdir"
  [ -d "${temp_dir}/premkdir" ]
)
end_test

begin_test "docker host dir"
(
  set -eu

  if [ "${OS-}" = "Windows_NT" ]; then
    [ "$(docker_host_dir /tmp)" = "$(cygpath -w /tmp)" ]
  else
    [ "$(docker_host_dir /tmp)" = "/tmp" ]
  fi
)
end_test

begin_test "Docker volume string parsing"
(
  set -eu

  host_paths=("."
              "/"
              "C:\\"
              "/foo/bar"
              "/foo/b  ar"
              "D:/foo/bar"
              "D:\\foo\\bar"
              "vl"
             )

  docker_paths=("/test/this"
                "/te st/th  is"
                "C:\\"
                "z")
  test_volume_flags=(""
                     ":ro"
                     ":ro:z"
                     ":z:ro"
                     ":Z:rshared:rw:nocopy")

  if docker_parse_volume_string garbage; then
    return 1
  fi

  for host_path in "${host_paths[@]}"; do
    for docker_path in "${docker_paths[@]}"; do
      for test_volume_flag in "${test_volume_flags[@]}"; do
        docker_parse_volume_string "${host_path}:${docker_path}${test_volume_flag}"
        [ "${volume_host}" = "${host_path}" ]
        [ "${volume_docker}" = "${docker_path}" ]
        [ "${volume_flags}" = "${test_volume_flag}" ]
      done
    done
  done
)
end_test

begin_test "Santize Volumes"
(
  set -eu

  temp_dir="${TRASHDIR}/sv"

  [ ! -e "${temp_dir}" ]

  if [ "${OS-notwindows}" = "Windows_NT" ]; then
    [ "$(docker_sanitize_volume ${temp_dir})" = "$(cygpath -w "${temp_dir}"):/${temp_dir}" ]
    [ "$(docker_sanitize_volume ${temp_dir} /foo)" = "$(cygpath -w "${temp_dir}")://foo" ]
  else
    [ "$(docker_sanitize_volume ${temp_dir})" = "${temp_dir}:${temp_dir}" ]
    [ "$(docker_sanitize_volume ${temp_dir} /bar)" = "${temp_dir}:/bar" ]
  fi

  [ -e "${temp_dir}" ]
)
end_test

begin_test "Parse docker args"
(
  set -eu
  parse-docker --config=blah.json -D -v run -v /foo:/bar debian:9 bash
  a1=(--config=blah.json -D -v)
  a2=(-v /foo:/bar debian:9 bash)
  cmp_elements_a docker_args a1
  [ "${docker_command}" = "run" ]
  cmp_elements_a docker_command_args a2
)
end_test

begin_test "Docker command"
(
  set -eu
  export DRYRUN=print_command

  DOCKER_AUTOREMOVE=0
  a=($DOCKER run -v '/test  this/:blah' 'debian:9')
  r="$(Docker run -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test

begin_test "DOCKER_AUTOREMOVE and DOCKER_EXTRA_*_ARGS"
(
  set -eu
  export DRYRUN=print_command

  a=("${DOCKER}" run --rm -v '/test  this/:blah' 'debian:9')
  r="$(Docker run -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r

  DOCKER_EXTRA_RUN_ARGS=('aaa' 'bbb')
  a=("${DOCKER}" run --rm aaa bbb -v '/test  this/:blah' 'debian:9')
  r="$(Docker run -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test

begin_test "DOCKER_EXTRA_ARGS"
(
  set -eu
  export DRYRUN=print_command

  DOCKER_EXTRA_BUILD_ARGS=('aaa' 'bbb')
  DOCKER_EXTRA_ARGS=(--config bl\ \ ah.json -l=debug -H 123)
  a=("${DOCKER}" --tls "${DOCKER_EXTRA_ARGS[@]}" build aaa bbb -v '/test  this/:blah' 'debian:9')
  r="$(Docker --tls build -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test





begin_test "Test DOCKER_COMPOSE var"
(
  set -eu
  DRYRUN=echo
  DOCKER_COMPOSE="DoCkEr-CoMpOsE"
  [ "$(Docker-compose run test)" = "DoCkEr-CoMpOsE run --rm test" ]
)
end_test

begin_test "docker compose parse volumes"
(
  set -eu

  ans=(-v "/tmp:/mnt" -v "test:/opt")
  docker-compose-volumes nb <<< "${compose_file}"
  cmp_elements_a DOCKER_VOLUME_FLAGS ans

  ans=()
  docker-compose-volumes foo <<< "${compose_file}"
  cmp_elements_a DOCKER_VOLUME_FLAGS ans

  docker-compose-volumes bar <<< "${compose_file}"
  cmp_elements_a DOCKER_VOLUME_FLAGS ans

  docker-compose-volumes none <<< "${compose_file}"
  cmp_elements_a DOCKER_VOLUME_FLAGS ans
)
end_test

begin_test "Parse docker-compose args"
(
  set -eu

  parse-docker-compose --no-ansi -H=blah.json --verbose run -v /foo:/bar debian bash
  a1=(--no-ansi -H=blah.json --verbose)
  a2=(-v /foo:/bar debian bash)
  cmp_elements_a docker_compose_args a1
  [ "${docker_compose_command}" = "run" ]
  cmp_elements_a docker_compose_command_args a2
)
end_test

begin_test "Parse docker compose file args"
(
  set -euE

  temp_dir="${TRASHDIR}/file"
  mkdir -p "${temp_dir}"
  pushd "${temp_dir}"
    touch docker-compose2.yml

    parse-docker-compose run alpine
    # No docker-compose
    [ "${docker_compose_project_name}" = "default" ]
    [ "${#docker_compose_files[@]}" -eq 0 ]

    # Make sure COMPOSE_FILE works
    COMPOSE_FILE=docker-compose2.yml parse-docker-compose run alpine
    [ "${docker_compose_project_name}" = "file" ]
    [ "${#docker_compose_files[@]}" -eq 1 ]
    [ "${docker_compose_files[0]}" = "docker-compose2.yml" ]

    # Make sure COMPOSE_FILE overrides docker-compose.yml
    touch docker-compose.yml
    COMPOSE_FILE=docker-compose2.yml parse-docker-compose run alpine
    [ "${docker_compose_project_name}" = "file" ]
    [ "${#docker_compose_files[@]}" -eq 1 ]
    [ "${docker_compose_files[0]}" = "docker-compose2.yml" ]

    # Make sure docker-compose.yml works
    parse-docker-compose run alpine
    [ "${docker_compose_project_name}" = "file" ]
    [ "${#docker_compose_files[@]}" -eq 1 ]
    [ "${docker_compose_files[0]}" = "${temp_dir}/docker-compose.yml" ]

    # Make sure override works
    touch docker-compose.override.yaml
    parse-docker-compose run alpine
    [ "${docker_compose_project_name}" = "file" ]
    [ "${#docker_compose_files[@]}" -eq 2 ]
    [ "${docker_compose_files[0]}" = "${temp_dir}/docker-compose.yml" ]
    [ "${docker_compose_files[1]}" = "${temp_dir}/docker-compose.override.yaml" ]

    # Make sure -f/--file wins
    COMPOSE_FILE=docker-compose2.yml parse-docker-compose -f test3.yml run alpine
    [ "${docker_compose_project_name}" = "file" ]
    [ "${#docker_compose_files[@]}" -eq 1 ]
    [ "${docker_compose_files[0]}" = "test3.yml" ]

    parse-docker-compose -f test1.yml -ftest2 --file test3 --file=test4 run debian:9 bash
    [ "${#docker_compose_files[@]}" -eq 4 ]
  popd
)
end_test

begin_test "Compose IFS non-Windows"
(
  set -eu
  unset OS
  [ "$(compose_path_separator)" = ":" ]
)
end_test

begin_test "Compose IFS Windows"
(
  set -eu
  OS="Windows_NT"
  [ "$(compose_path_separator)" = ";" ]
)
end_test

begin_test "Custom IFS"
(
  set -eu
  COMPOSE_PATH_SEPARATOR='|'
  OS="Windows_NT"
  [ "$(compose_path_separator)" = "|" ]
  unset OS
  [ "$(compose_path_separator)" = "|" ]
)
end_test

begin_test "Docker-compose command"
(
  set -eu
  export DRYRUN=print_command

  DOCKER_COMPOSE_AUTOREMOVE=0
  a=($DOCKER_COMPOSE run -v '/test  this/:blah' 'debian:9')
  r="$(Docker-compose run -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test

begin_test "DOCKER_COMPOSE_AUTOREMOVE and DOCKER_COMPOSE_EXTRA_*_ARGS"
(
  set -eu
  export DRYRUN=print_command

  a=("${DOCKER_COMPOSE}" run --rm -v '/test  this/:blah' 'debian')
  r="$(Docker-compose run -v "/test  this/:blah" debian)"
  eval "r=($r)"
  cmp_elements_a a r

  DOCKER_COMPOSE_EXTRA_RUN_ARGS=('aaa' 'bbb')
  a=("${DOCKER_COMPOSE}" run --rm aaa bbb -v '/test  this/:blah' 'debian')
  r="$(Docker-compose run -v "/test  this/:blah" debian)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test

begin_test "DOCKER_COMPOSE_EXTRA_ARGS"
(
  set -eu
  export DRYRUN=print_command

  DOCKER_COMPOSE_EXTRA_BUILD_ARGS=('aaa' 'bbb')
  DOCKER_COMPOSE_EXTRA_ARGS=(--config bl\ \ ah.json -l=debug -H 123)
  a=("${DOCKER_COMPOSE}" --tls "${DOCKER_COMPOSE_EXTRA_ARGS[@]}" build aaa bbb -v '/test  this/:blah' 'debian')
  r="$(Docker-compose --tls build -v "/test  this/:blah" debian)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test

begin_test "docker-compose service names"
(
  set -eu
  service_names="$(docker_compose_service_names <(echo "${compose_file}"))"

  ans="nb foo bar"
  cmp_elements service_names ans
)
end_test

begin_test "filter docker variables"
(
  set -eu

  PROJECT_VAR1=15
  VAR2_DOCKER=16
  PROJECT_VAR1_DOCKER=17

  JUST_FILTER_DOCKER=0 filter_docker_variables PROJECT
  [ "${PROJECT_VAR1-}" = "15" ]
  [ "${VAR2_DOCKER-}" = "16" ]
  [ "${PROJECT_VAR1_DOCKER-}" = "17" ]

  filter_docker_variables PROJECT
  [ "${PROJECT_VAR1-}" = "15" ]
  [ "${VAR2_DOCKER-}" = "16" ]
  [ -z "${PROJECT_VAR1_DOCKER+_}" ]
)
end_test

begin_test "Docker compose santize project names"
(
  set -eu

  [ "$(docker_compose_sanitize_project_name 'project/A@1.1_2')" = "a112" ]
  [ "$(docker_compose_sanitize_project_name 'project/A@1.1_2' 'auser:7')" = "auser7a112" ]
  [ "$(docker_compose_sanitize_project_name '' 'a-user:7')" = "auser7" ]
)
end_test

command -v "${DOCKER}" >&/dev/null || skip_next_test
begin_test "Just docker compose"
(
  set -eu

  check_skip

  JUST_PROJECT_PREFIX=TEST

  temp_dir="${TRASHDIR}/jdc"
  mkdir -p "${temp_dir}"
  touch "${temp_dir}/Dockerfile"
  echo "${compose_file_hay}" > "${temp_dir}/Dockerfile"

  [ "$(Just-docker-compose -f "${temp_dir}/Dockerfile" run test_hay)" = "horse" ]
)
end_test

begin_test "Just docker compose override files"
(
  set -eu
  JUST_PROJECT_PREFIX=TEST

  ans="version: '3.2'
services:
  test_hay:"

  echo "${compose_file_hay}" > "${TRASHDIR}/dc.yml"
  DRYRUN=echo

  override_file="$(Just-docker-compose -f "${TRASHDIR}/dc.yml" run test_hay|tail -n1)"
  override_file="${override_file#rm *}"
  ttouch "${override_file}"
  [ "$(cat "${override_file}")" = "${ans}" ]

  #Test where two docker-compose files reference the same service
  echo "${compose_file_hay}" > "${TRASHDIR}/dc2.yml"
  override_file="$(Just-docker-compose -f "${TRASHDIR}/dc.yml" -f "${TRASHDIR}/dc2.yml" run test_hay|tail -n1)"
  override_file="${override_file#rm *}"
  ttouch "${override_file}"
  [ "$(cat "${override_file}")" = "${ans}" ]
)
end_test

begin_must_fail_test "Just docker compose required project prefix"
(
  unset JUST_PROJECT_PREFIX
  echo "${compose_file_hay}" > "${TRASHDIR}/dc.yml"
  set -eu
  Just-docker-compose -f "${TRASHDIR}/dc.yml" run test_hay
)
end_test

command -v "${DOCKER_COMPOSE}" >&/dev/null || skip_next_test
begin_test "Docker service running"
(
  set -eu

  check_skip

  "${DOCKER_COMPOSE}" -f <(echo "${compose_file_sleep}") rm -s -f
  "${DOCKER_COMPOSE}" -f <(echo "${compose_file_sleep}") up -d test_sleepy
  [ "$(COMPOSE_FILE=<(echo "${compose_file_sleep}") docker_service_running test_sleepy)" = "running" ]
  [ "$(COMPOSE_FILE=<(echo "${compose_file_sleep}") docker_service_running test_sleepy2)" = "" ]
  "${DOCKER_COMPOSE}" -f <(echo "${compose_file_sleep}") kill test_sleepy
  [ "$(COMPOSE_FILE=<(echo "${compose_file_sleep}") docker_service_running test_sleepy)" = "exited" ]

  #Clean up
  "${DOCKER_COMPOSE}" -f <(echo "${compose_file_sleep}") rm -s -f
)
end_test

teardown()
(
  # Docker cleanup
  ! ${DOCKER} rm test-docker-function &>/dev/null

  : #teardown should always return true on success
)
