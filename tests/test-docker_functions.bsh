
. "$(dirname ${BASH_SOURCE[0]})/testlib.sh"
. "$(dirname ${BASH_SOURCE[0]})/test_utils.bsh"

VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
. "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
. "${VSI_COMMON_DIR}/linux/just_functions.bsh"
. "${VSI_COMMON_DIR}/linux/elements.bsh"

setup()
{
  temp_dir="$(mktemp -d -u)"
}

begin_test "Santize Volumes"
(
  set -eu

  temp_dir="${temp_dir}/sv"

  [ ! -e "${temp_dir}" ]

  if [ "${OS-notwindows}" == "Windows_NT" ]; then
    [ "$(docker_sanitize_volume ${temp_dir})" == "$(cygpath -w "${temp_dir}"):/${temp_dir}" ]
  else
    [ "$(docker_sanitize_volume ${temp_dir})" == "${temp_dir}:${temp_dir}" ]
  fi

  [ -e "${temp_dir}" ]
)
end_test

begin_test "Docker volume string parsing"
(
  set -eu

  host_paths=("/foo/bar"
              "/foo/b  ar"
              "D:/foo/bar"
              "D:\foo\bar"
              "vl"
             )

  docker_paths=("/test/this"
                "/te st/th  is"
                "z")
  test_volume_flags=(""
                     ":ro"
                     ":ro:z"
                     ":z:ro"
                     ":Z:rshared:rw:nocopy")

  if docker_parse_volume_string garbage; then
    return 1
  fi

  for host_path in "${host_paths[@]}"; do
    for docker_path in "${docker_paths[@]}"; do
      for test_volume_flag in "${test_volume_flags[@]}"; do
        docker_parse_volume_string "${host_path}:${docker_path}${test_volume_flag}"
        [ "${volume_host}" = "${host_path}" ]
        [ "${volume_docker}" = "${docker_path}" ]
        [ "${volume_flags}" = "${test_volume_flag}" ]
      done
    done
  done
)
end_test

begin_test "Parse docker compose file args"
(
  parse-docker-compose -f test1.yml -ftest2 --file test3 --file=test4 run debian:9 bash
  [ "${#docker_compose_files[@]}" = 4 ]
)
end_test

begin_test "Docker command"
(
  set -eu
  export DRYRUN=print_command

  DOCKER_AUTOREMOVE=0
  a=(docker run -v '/test  this/:blah' 'debian:9')
  r="$(Docker run -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test
begin_test "DOCKER_AUTOREMOVE and DOCKER_EXTRA_*_ARGS"
(
  set -eu
  export DRYRUN=print_command

  a=(docker run --rm -v '/test  this/:blah' 'debian:9')
  r="$(Docker run -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r

  DOCKER_EXTRA_RUN_ARGS=('aaa' 'bbb')
  a=(docker run --rm aaa bbb -v '/test  this/:blah' 'debian:9')
  r="$(Docker run -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test
begin_test "DOCKER_EXTRA_ARGS"
(
  set -eu
  export DRYRUN=print_command

  DOCKER_EXTRA_BUILD_ARGS=('aaa' 'bbb')
  DOCKER_EXTRA_ARGS=(--config bl\ \ ah.json -l=debug -H 123)
  a=(docker --tls "${DOCKER_EXTRA_ARGS[@]}" build aaa bbb -v '/test  this/:blah' 'debian:9')
  r="$(Docker --tls build -v "/test  this/:blah" debian:9)"
  eval "r=($r)"
  cmp_elements_a a r
)
end_test

begin_test "Compose IFS non-Windows"
(
  set -eu
  unset OS
  [ "$(compose_path_separator)" == ":" ]
)
end_test

begin_test "Compose IFS Windows"
(
  set -eu
  OS="Windows_NT"
  [ "$(compose_path_separator)" == ";" ]
)
end_test

begin_test "Custom IFS"
(
  set -eu
  COMPOSE_PATH_SEPARATOR='|'
  OS="Windows_NT"
  [ "$(compose_path_separator)" == "|" ]
  unset OS
  [ "$(compose_path_separator)" == "|" ]
)
end_test

begin_test "Test DOCKER var"
(
  set -eu
  DRYRUN=echo
  DOCKER="DoCkEr"
  [ "$(Docker run test)" == "DoCkEr run --rm test" ]
)

begin_test "Test NVIDIA_DOCKER var"
(
  set -eu
  DRYRUN=echo
  NVIDIA_DOCKER="NvIdIa-DoCkEr"
  [ "$(Nvidia-docker run test)" == "NvIdIa-DoCkEr run --rm test" ]
)

begin_test "is_dir_and_not_exist"
(
  set -eu
  not is_dir_and_not_exist qwertyuiop
  is_dir_and_not_exist /
)

teardown()
(
  #remove all dirs. Trying to be safe here. Will fail if any dir is not empty
  find "${temp_dir}" -type d -depth -exec rmdir \{\} \;
)
