#!/usr/bin/env bash
#D.U.S.T.I.F.Y. - Docker Uncomplicated Simplified Tasking Identified For You

set -eu

SCRIPT_DIR=$(cd $(dirname ${BASH_SOURCE[0]}); pwd)
. ${SCRIPT_DIR}/just_functions.bsh

if [ -f .dustifyfile ]; then 
  safe_load .dustifyfile
fi

### Functions

get_label() # Get the value of a label ($2) from container/image ($1)
{ # All labels go through a perl filter that evaluate %name% using exported
  # environment variables. This won't work on unexported variables
  value=$(docker inspect -f "{{index .Config.Labels \"$2\"}}" $1)
  if [ "${value}" == "<no value>" ]; then
    return 1
  fi

  value=$(echo "${value}" | perl -wpe 's#\%?(\w+)\%# $ENV{$1} // $& #ge;')

  return 0
}

Docker() #Helper function to execute the right docker command, or just echo
{
  if [ "${NVIDIA_DOCKER}" == "1" ]; then
    cmd="${DRYRUN} nvidia-docker"
  else
    cmd="${DRYRUN} docker"
  fi

  command $cmd "${@}"
}

###### Default variables used in commands ######
: ${DOCKERFILE=Dockerfile}
: ${NVIDIA_DOCKER=0}
: ${IMAGENAME=$(basename $(pwd))}
: ${CONTEXT=$(pwd)}

## Dockerfile variables, accessible via %name% notation in a label
# I decided not to go with a blind eval, for security reasons. Instead 
# variables need to be added  to this section instead, and hopefully be enough
set -a #Turn on auto export

: ${DUSTIFY_USER_ID=$(id -u)}
: ${DUSTIFY_GROUP_ID=$(id -g)}

set +a #Turn off auto export

caseify() #Main justify core
{
  arg=$1
  extra_args=0
  shift 1
  case ${arg} in
    -file|--f) #Specify alternative Dockerfile for build
      DOCKERFILE=$1
      extra_args=1
      ;;
    -image) #Specify alternative image name, else directory basename is used
      IMAGENAME=$1
      extra_args=1
      ;;
    -context) #Specify a different context dir
      CONTEXT=$1
      extra_args=1
      ;;
    build) #Build a docker image
      build()
      {
        local unique=tmp_$(head -c 16 /dev/urandom | xxd -pu)
        Docker build -t ${unique} ${@+"${@}"} -f ${DOCKERFILE} ${CONTEXT}
        Docker tag ${unique} ${IMAGENAME}
        if [ "${DRYRUN}" == "" ]; then
          Docker rmi ${unique} > /dev/null
        else
          Docker rmi ${unique}
        fi
      }
      callify build ${@+"${@}"}
      ;;
    -args)
      get_args "${@}"
      pre_args=("${args[@]}")
      ;;
    run) #Runs a docker container
      run()
      {
        local run_args=()
        run_args+=(-l "dustify.image=$IMAGENAME")
        if get_label ${IMAGENAME} dustify.runargs; then
          run_args+=(${value})
        fi
        if [ "${pre_args:+0}" == "0" ]; then
          run_args+=("${pre_args[@]}")
          unset pre_args
        fi
        if get_label ${IMAGENAME} com.nvidia.volumes.needed && [ "${value}" == "nvidia_driver" ]; then
          NVIDIA_DOCKER=1
        fi

        Docker run -it --rm "${run_args[@]}" ${IMAGENAME} ${@+"${@}"}
      }
      callify run ${@+"${@}"}
      ;;
    runlast) #Runs the image of the last exited container. This is useful when building, as this will be the last snapshot before a failed build
      docker run -it --rm $(docker ps -a --filter=status=exited --format '{{.Image}}' | head -n 1) bash
      ;;
    daemon) #Runs a docker container as a daemon
      daemon()
      {
        echo TODO: daemon
      }
      callify daemon ${@+"${@}"}
      ;;
    enter) #Conveniently start an interactive bash in a running container
      Docker ps --filter=label=dustify.image=${IMAGENAME} --format="{{.Names}}"
      ;;
    push)
      Docker push ${IMAGENAME}
      ;;
    pull)
      Docker pull ${IMAGENAME}
      ;;
    *)
      defaultify $arg ${@+"${@}"}
      ;;
  esac
}

justify "${@}"
