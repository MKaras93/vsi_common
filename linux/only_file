#!/usr/bin/env false

source "${VSI_COMMON_DIR}/linux/only_functions.bsh"

: ${ONLYFILE=.onlyfile}
if [ -f "${ONLYFILE}" ]; then 
  export ONLY_DIR="$(cd "$(dirname "${ONLYFILE}")"; pwd)"
  safe_load "${ONLYFILE}"
else
  export ONLY_DIR="$(pwd)"
fi

###### Default variables used in commands ######
: ${DOCKERFILE=Dockerfile}
: ${IMAGENAME=$(basename "$(pwd)")}
: ${CONTEXT=$(pwd)}

## Dockerfile variables, accessible via %name% notation in a label
# I decided not to go with a blind eval, for security reasons. Instead 
# variables need to be added  to this section instead, and hopefully be enough
set -a #Turn on auto export

: ${ONLY_USER_ID=$(id -u)}
: ${ONLY_GROUP_ID=$(id -g)}

set +a #Turn off auto export

caseify() #Main justify core
{
  arg=$1
  shift 1
  case ${arg} in
    -file|--f) #Specify alternative Dockerfile for build
      DOCKERFILE=$1
      extra_args=1
      ;;
    -image) #Specify alternative image name, else directory basename is used
      IMAGENAME=$1
      extra_args=1
      ;;
    -context) #Specify a different context dir
      CONTEXT=$1
      extra_args=1
      ;;
    build) #Build a docker image
      build()
      {
        local unique=tmp_$(head -c 16 /dev/urandom | od -tx1 -An | tr -d '\n ')
        Docker build -t ${unique} ${@+"${@}"} -f ${DOCKERFILE} ${CONTEXT}
        Docker tag ${unique} ${IMAGENAME}
        if [ "${DRYRUN}" == "" ]; then
          Docker rmi ${unique} > /dev/null
        else
          Docker rmi ${unique}
        fi
      }
      callify build ${@+"${@}"}
      ;;
    run) #Runs a docker container
      run()
      {
        local run_args=()
        run_args+=(-l "only.image=$IMAGENAME")
        if get_label ${IMAGENAME} only.runargs; then
          run_args+=(${value})
        fi
        if [ "$(uname)" == "Linux" ]; then
          if get_label ${IMAGENAME} only.linux_runargs; then
            run_args+=(${value})
          fi
        elif [ "$(uname)" == "Darwin" ]; then
          if get_label ${IMAGENAME} only.mac_runargs; then
            run_args+=(${value})
          fi
        else
          if get_label ${IMAGENAME} only.windows_runargs; then
            run_args+=(${value})
          fi
        fi
        if [ "${pre_args:+0}" == "0" ]; then
          run_args+=("${pre_args[@]}")
          unset pre_args
        fi
        if get_label ${IMAGENAME} com.nvidia.volumes.needed && [ "${value}" == "nvidia_driver" ]; then
          USE_NVIDIA_DOCKER=1
        fi

        Docker run -it --rm "${run_args[@]}" ${IMAGENAME} ${@+"${@}"}
      }

      get_args ${@+"${@}"}
      pre_args=(${args+"${args[@]}"})
      get_additional_args ${@+"${@}"}
      run ${args+"${args[@]}"}
      ;;
    runlast) #Runs the image of the last exited container. This is useful when building, as this will be the last snapshot before a failed build
      Docker run -it --rm $(docker ps -a --filter=status=exited --format '{{.Image}}' | head -n 1) bash
      ;;
    runlast2)
      Docker run -it --rm $(docker commit $(docker ps -a --filter=status=exited --format '{{.ID}}' | head -n 1) ) bash
      ;;
    daemon) #Runs a docker container as a daemon
      daemon()
      {
        echo TODO: daemon
      }
      callify daemon ${@+"${@}"}
      ;;
    enter) #Conveniently start an interactive bash in a running container
      Docker ps --filter=label=only.image=${IMAGENAME} --format="{{.Names}}"
      ;;
    push)
      Docker push ${IMAGENAME}
      ;;
    pull)
      Docker pull ${IMAGENAME}
      ;;
    *)
      defaultify $arg ${@+"${@}"}
      ;;
  esac
}
