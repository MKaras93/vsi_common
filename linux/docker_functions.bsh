#!/usr/bin/env false
#Source this script for docker specific helper functions for just or other

### docker and nvidia-docker ###

: ${DOCKER=docker}
: ${NVIDIA_DOCKER=nvidia-docker}
if ! hash ${NVIDIA_DOCKER} 2> /dev/null; then
  NVIDIA_DOCKER=${DOCKER}
fi

#These 4 may need to be redone next time they are used
function Exec-Nvidia-Docker(){ DOCKER_EXEC=1 USE_NVIDIA_DOCKER=1 Docker "${@}";}
function Nvidia-Docker(){ USE_NVIDIA_DOCKER=1 Docker "${@}";}
function Exec-Docker(){ DOCKER_EXEC=1 Docker "${@}";}
function Docker() #Helper function to execute the right docker command, or just echo
{
  local cmd

  if [ "${USE_NVIDIA_DOCKER-}" == "1" ]; then
    cmd=(${DRYRUN} "${NVIDIA_DOCKER}")
  else
    cmd=(${DRYRUN} "${DOCKER}")
  fi

  if [ "$1" == "run" ]; then
    cmd+=($1 "${DOCKER_RUN_ARGS[@]}")
    shift 1
  fi

  if [ "${DOCKER_EXEC-}" == "" ] || [ "${DRYRUN}" != "" ]; then
    "${cmd[0]}" "${cmd[@]:1}" "${@}"
  else
    exec "${cmd[@]}" "${@}"
  fi
}

### docker-compose ###

: ${DOCKER_COMPOSE=docker-compose}
: ${DOCKER_COMPOSE_AUTOREMOVE=1}

function Docker-compose()
{
  local parsed_args=()

  if [ "${DOCKER_COMPOSE_AUTOREMOVE}" == "1" ]; then
    while (( $# )); do
      case "$1" in
        run)
          shift 1
          ${DRYRUN} ${DOCKER_COMPOSE} ${parsed_args+"${parsed_args[@]}"} run --rm "${@}"
          return
          ;;
        -f*|-p*|-H*)
          if [ "${#1}" == 2 ]; then
            parsed_args+=("$1" "$2")
            shift 2
          else
            parsed_args+=("$1")
            shift 1
          fi
          ;;
        --file=*|--project-name=*|--host=*|\
        --tlscacert=*|--tlscert=*|--tlskey=*|--project-directory=*|\
        -v|--verbose|--tls|--skip-hostname-check|--tlsverify)
          parsed_args+=("$1")
          shift 1
          ;;
        --file|--project-name|--host|\
        --tlscacert|--tlscert|--tlskey|--project-directory)
          parsed_args+=("$1" "$2")
          shift 2
          ;;
        *)
          ${DRYRUN} ${DOCKER_COMPOSE} ${parsed_args+"${parsed_args[@]}"} "${@}"
          return
          ;;
      esac
    done
    # If you get here, I'm PRETTY sure the command is ill-formed, but in case
    # I'm wrong, here goes...
    ${DRYRUN} ${DOCKER_COMPOSE} ${parsed_args+"${parsed_args[@]}"} "${@}"
  else
    ${DRYRUN} ${DOCKER_COMPOSE} "${@}"
  fi
}

### powershell setup ###
# Cygwin bash is pretty bad. The new git bash (MINGW64) does not have a tty.
# This is pretty bad for docker. Powershell does have a tty, buy can not run
# bash scrips natively. The solution is to run bash in powershell. These functions
# help with that.

function is_powershell()
{
  if [ "${VSI_COMMON_IS_POWERSHELL-0}" == "1" ]; then
    return 0
  fi

  local unique_title=$(head -c 16 /dev/urandom | xxd -pu)
  echo -en "\033]0;${unique_title}\a"
  if [ $(tasklist //fi "windowtitle eq ${unique_title}" | tail -n 1 | awk '{print $1}') == "powershell.exe" ]; then
    return 0
  else
    return 1
  fi
}

function setup_powershell()
{ # Usage: setup_powershell ${@+"${@}"}
  # This is designed to rerun a script being called from. Do not call from command line
  if [ "${OS-notwindows}" == "Windows_NT" ] && ! is_powershell; then
    if [ "${#@}" == "0" ]; then
      setup_powershell _null
    else
      exec env VSI_COMMON_IS_POWERSHELL=1 start powershell "cmd /c color 07; bash \"$0\" ${@}; bash --rcfile \"${VSI_COMMON_DIR}/.winbashrc\""
    fi
  fi
}