#!/usr/bin/env false

#****f* file_tools.bsh/find_open_fd
# NAME
#   find_open_fd - Find the first open file descriptor
# OUTPUT
#   fd - Value of next unused file descriptor
# USAGE
#   This is for backwards compatibility. In bash 4.1 or newer, this isn't
#   necessary, as:
#
#     exec {fd}<>${some_buffer}
#     echo "hi" >&${fd}
#     read -u${fd} some_var
#     exec {fd}>&-
#
#   is better.
# BUGS
#   Probably not thread safe
# SEE ALSO
#   open_fd, close_fd
# AUTHOR
#   Andy Neff
#***
function find_open_fd()
{
  for ((fd=3; fd<$(ulimit -n); fd++)); do
    if ! : 2>/dev/null >&${fd}; then
      return 0
    fi
  done
  return 1
}

#****f* file_tools.bsh/open_fd
# NAME
#   open_fd - Find available file descriptor
# INPUTS
#   [1] - File descriptor number. Default: Find next open fd
#   [fifo_buffer] - FIFO buffer used
# OUTPUT
#   fd - The fd number
# BUGS
#   You can't do
#
#     output=$(open_fd)
#
#   Because open_fd will be executed in a subshell, and thus the opened fd will
#   be useless. This is the design decision behind storing the file descriptor
#   in the fd variable
# EXAMPLE
#   # Make a pipe
#   pipe="$(mktemp -u)"
#   mkfifo "${pipe}"
#
#   #Open the pipe
#   fifobuffer="${pipe}" open_fd
#
#   # Write to the pipe - does not block as long as buffer not filled
#   echo "hi" >&${fd}
#
#   # Read from pipe, blocking. Use timeout command to add a timeout
#   timeout 1 cat - <&${fd}
#
#   # Read from the pipe and save to a variable without a subshell
#   IFS='' read -u "${fd}" -t 0.1 -r my_variable
#
#   # close and cleanup
#   close_fd "${fd}"
#   rm "${pipe}"
# SEE ALSO
#   file_tools.bsh/close_fd time_tools.bsh/timeout
#***
function open_fd()
{
  # Get fd
  if ! (( $# )); then
    find_open_fd
  else
    fd=$1
  fi

  # Setup a fifo buffer for one use
  if ! declare -p fifo_buffer&>/dev/null; then
    FILE_TOOLS_DELETE_BUFFER=1
    fifo_buffer="$(mktemp -u)"
    mkfifo "${fifo_buffer}"
  fi

  # Redirect 3 to the fifo buffer
  eval "exec ${fd}<>'${fifo_buffer}'"
}


# INPUTS
#   1 - fd number
function close_fd()
{
  eval "exec ${1}>&-"

  # Delete that fifo buffer after one use
  if [ "${FILE_TOOLS_DELETE_BUFFER-}" == "1" ]; then
    rm "${fifo_buffer}"
    unset FILE_TOOLS_DELETE_BUFFER
  fi
}
