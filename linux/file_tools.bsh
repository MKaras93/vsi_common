#!/usr/bin/env false

#****f* file_tools.bsh/find_open_fd
# NAME
#   find_open_fd - Find the first open file descriptor
# OUTPUT
#   fd - Value of next unused file descriptor
# USAGE
#   This is for backwards compatibility. In bash 4.1 or newer, this isn't
#   necessary, as:
#
#     exec {fd}<>${some_buffer}
#     echo "hi" >&${fd}
#     read -u${fd} some_var
#     exec {fd}>&-
#
#   is better.
# BUGS
#   Probably not thread safe
# SEE ALSO
#   open_fd, close_fd
# AUTHOR
#   Andy Neff
#***
function find_open_fd()
{
  for ((fd=3; fd<$(ulimit -n); fd++)); do
    if ! : 2>/dev/null >&${fd}; then
      return 0
    fi
  done
  return 1
}

#****f* file_tools.bsh/open_fd
# NAME
#   open_fd - Find available file descriptor
# INPUTS
#   [1] - File descriptor number for reading[/writing]. Default: Find next open fd
#   [2] - File descriptor number for writing. Default: Find next open fd
#   [fifo_buffer] - FIFO buffer used
#   [same_fd] - Use the same fd for reading and writing. Default: 0 (disabled)
# OUTPUT
#   fd_r - The fd number for reading
#   fd_w - The fd number for writing
# USAGE
#   You can't do
#
#     output=$(open_fd)
#
#   Because open_fd will be executed in a subshell, and thus the opened fd will
#   be useless. This is the design decision behind storing the file descriptor
#   in the fd variable
# EXAMPLE
#   # Make a pipe
#   pipe="$(mktemp -u)"
#   mkfifo "${pipe}"
#
#   #Open the pipe
#   fifobuffer="${pipe}" open_fd
#
#   # Write to the pipe - does not block as long as buffer not filled
#   echo "hi" >&${fd}
#
#   # Read from pipe, blocking. Use timeout command to add a timeout
#   timeout 1 cat - <&${fd}
#
#   # Read from the pipe and save to a variable without a subshell
#   IFS='' read -u "${fd}" -t 0.1 -r my_variable
#
#   # close and cleanup
#   close_fd "${fd}"
#   rm "${pipe}"
# SEE ALSO
#   file_tools.bsh/close_fd time_tools.bsh/timeout
#***
function open_fd()
{
  local fd

  # Setup a fifo buffer for one use
  if ! declare -p fifo_buffer&>/dev/null; then
    FILE_TOOLS_DELETE_BUFFER=1
    fifo_buffer="$(mktemp -u)"
    if [ "${OS-}" = "Windows_NT" ]; then
      # Windows doesn't implement pipe right.
      touch "${fifo_buffer}"
    else
      mkfifo "${fifo_buffer}"
    fi
  fi

  # Get reading fd
  if [ "$#" -lt 1 ]; then
    find_open_fd
    fd_r="${fd}"
  else
    fd_r="$1"
  fi

  # If the same fd is to be used for reading and writing
  if [ "${same_fd-0}" != "0" ] || [ "${1-null}" = "${2-}" ]; then
    # Redirect to the buffer
    eval "exec ${fd_r}<>'${fifo_buffer}'"
  else
    # Open read now, so the next find_open_fd will find a new one
    eval "exec ${fd_r}<'${fifo_buffer}'"

    if [ "$#" -lt 2 ]; then
      find_open_fd
      fd_w="${fd}"
    else
      fd_w="$2"
    fi

    eval "exec ${fd_w}>'${fifo_buffer}'"
  fi
}


# INPUTS
#   1 - fd number
#   [2] - fd number
function close_fd()
{
  eval "exec ${1}>&-"
  if [ $# -gt 1 ]; then
    eval "exec ${2}>&-"
  fi

  # Delete that fifo buffer after one use
  if [ "${FILE_TOOLS_DELETE_BUFFER-}" == "1" ]; then
    rm "${fifo_buffer}"
    unset FILE_TOOLS_DELETE_BUFFER
  fi
}
