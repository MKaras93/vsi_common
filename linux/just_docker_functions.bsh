JUST_DEFAULTIFY_FUNCTIONS+=(docker_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"

#*# just/plugins/docker/just_docker_functions

#**
# =========================
# J.U.S.T. Docker Functions
# =========================
#
# .. default-domain:: bash
#
# .. file:: just_docker_functions.bsh
#
# .. function:: docker_defaultify
#
# .. command:: build_recipes
#
# :Arguments: [``$1``]... - Recipe names to run
#
# Runs ``docker-compose build`` for the docker recipes. Useful command to call before ``docker build`` on your own project that uses recipes in vsi_common, to keep them synced with your build.
#
# .. command:: log
#
# :Arguments: [``$1``]... - Service names
#
# Show logs from all service containers. Optionally specify service names to only log specific containers.
#
# .. warning::
#
# Does not pick up containers that didn't exist when starting ``just`` log
#
# Override the log target in your ``Justfile`` and call ``__docker-compose-log`` if you need to set other parameter.
#
# .. command:: docker_clean
#
# :Arguments: ``$1`` - Volume to be removed
#
# Runs ``docker volume rm`` on the specified volume. If the volume is in use, there are total of four options
#
# 1. ``ask`` - (default) Asks you if you want to attempt to stop the containers with a 30 second timeout and then forcefully remove the current containers mounting the volume
# 2. ``delete`` - Mounts the volume, and deletes all of the files. May not work when a container is running a database, or the volume is
# 3. ``stop`` - Attempts to stop the containers with a 30 second timeout and then forcefully remove the current containers mounting the volume, without prompting
# 4. ``error`` - Errors out instead of cleaning the volume
#
# The action for a specific volume is specified by setting the label ``com.vsi.just.clean_action``
#
# For example, in a ``docker-compose.yaml`` file:
#
# .. code-block:: yaml
#
#   volumes:
#     venv:
#       labels:
#         com.vsi.just.clean_action: ask
#
#**
function docker_defaultify()
{
  arg=$1
  shift 1
  case $arg in
    build_recipes) # Build recipes
      JUST_DOCKER_COMPOSE_DIR="${VSI_COMMON_DIR}/docker/recipes" Docker-compose build ${@+"${@}"}
      extra_args+=$#
      ;;
    docker_clean) # Delete a docker volume. The next container to use this \
                  # volume will automatically copy any content from the image.
      if docker volume inspect "${1}" &> /dev/null; then
        local x=0
        local rm_out
        rm_out="$(Docker volume rm "${1}" 2>&1)" || x=$?

        echo "${rm_out}"

        if [ "${x}" != "0" ]; then
          local pattern='volume is in use - \[(.*)\]'
          [[ ${rm_out} =~ ${pattern} ]]
          local OLD_IFS="${IFS}"
          IFS=", "
          local containers=(${BASH_REMATCH[1]})
          IFS="${OLD_IFS}"

          pattern='"com\.vsi\.just\.clean_action": "([^"]+)"'
          local action
          if [[ $(docker volume inspect "${1}") =~ $pattern ]]; then
            action="${BASH_REMATCH[1]}"
          else
            action=ask
          fi

          case $action in
            ask)
              echo "The following containers are using ${1}:"
              echo "${containers[*]}"
              if command ask_question "Stop and remove these containers then try again?" n; then
                for x in "${containers[@]}"; do
                  Docker stop "${x}"
                  Docker rm "${x}" || :
                done
                Docker volume rm "${1}"
              else
                false
              fi
              ;;
            delete)
              Docker run -it --rm -v ${1}:/data alpine rm '/data/*' '/data/.*'
              ;;
            stop)
              for x in "${containers[@]}"; do
                Docker stop -t 30 "${x}"
                Docker rm -f "${x}" || :
              done
              Docker volume rm "${1}"
              ;;
            error)
              false
              ;;
            *)
              echo "Unknown action ${action}"
              false
              ;;
          esac
        fi
      else
        echo "${1} already removed" >&2
      fi

      extra_args+=1
      ;;
    docker-compose_clean) # Delete a docker-compose volume. The next container \
                          # to use this volume will automatically copy any
                          # content from the image.
      (justify docker_clean "${COMPOSE_PROJECT_NAME}_${1}")
      extra_args+=1
      ;;
    log) # Show logs from all service containers. Optionally specify service \
         # names to only log specific containers. Bug: Does not pick up \
         # containers that didn't exist when starting just log

      # Override the log target in your Justfile and call __docker-compose-log
      # if you need to set other parameters
      (justify __docker-compose-log ${@+"${@}"})
      extra_args+=$#
      ;;
    __docker-compose-log)
      function stop_logging(){ JUST_STOP_LOGGING=1; }
      JUST_STOP_LOGGING=0
      trap stop_logging INT
      trap stop_logging TERM
      while [ "${JUST_STOP_LOGGING}" == "0" ]; do
        Docker-compose logs --tail=20 -f ${@+"${@}"} || echo $?
        while [ "${JUST_STOP_LOGGING}" == "0" ] && ! docker_service_running | grep running > /dev/null; do
          sleep 1
        done
      done
      trap - INT
      trap - TERM
      extra_args+=$#
      ;;
    *)
      plugin_not_found=1
      ;;
  esac
  return 0
}
