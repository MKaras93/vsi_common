#!/usr/bin/env bash

##****F* just/docker_entrypoint.bsh
# NAME
#   docker_entrypoint.bsh - Functions to help write docker entrypoints
# INPUTS
#   See inputs for other SEE ALSO
# EXAMPLE
#   docker_entrypoint.bsh
# USAGE
#   Can also be sourced to call individual functions. By default, calling
#   docker_entrypoint.bsh runs
#   - docker_setup_user
# SEE ALSO
#   docker_setup_user
# AUTHOR
#   Andy Neff
##***

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/linux_accounts.bsh"
source "${VSI_COMMON_DIR}/linux/elements.bsh"

##****f* docker_entrypoint.bsh/docker_setup_user
# NAME
#   docker_setup_user - Create user/group
# PARAMETERS
#   [DOCKER_ACCOUNTS_CREATE_USER] - Enables the adding of a new user. If the
#                                   particular username already exist, it is
#                                   replaced. Default: 1
#   [DOCKER_ACCOUNTS_CREATE_GROUPS] - Enables the adding of new groups. The
#                                     first group is set as the user's primary
#                                     group. Each subsequent group is set as an
#                                     additional group, and the user is added as
#                                     a member of each of these groups. If a group
#                                     name already exists, an increasing number
#                                     is appended until the name does not exist.
#                                     if the GID already exists, it is just used
#                                     again. Default: 1
#   [DOCKER_ACCOUNTS_POSIX_GROUPS] - Enables filtering group names removing
#                                    non-posix characters. This is important for
#                                    operating systems like CentOS, etc... that
#                                    actually follow the posix rules, unlike
#                                    Debian. If 100% of the characters are
#                                    non-posix, the name becomes simply "group".
#                                    Default: 1
#   [DOCKER_USERNAME] - The username used to create the new user. Default: user
#   [DOCKER_UID] - The UID used when creating the new user. Default: 1000
#   [DOCKER_GROUP_NAMES] - The group name(s) used when creating the groups for
#                          the new user. IFS delimited string (default: space,
#                          tab, newline). Default: user (only the primary group)
#   [DOCKER_GIDS] - The GIDs used when creating the new groups. IFS delimited
#                   string. Default: 1000
#   [DOCKER_HOME] - The home directory used when creating a new user. When the new
#                   directory is created, it is owned (non-recursively) by the
#                   UID/GID. Default: /home/${DOCKER_USERNAME}
# AUTHOR
#   Andy Neff
##***
function docker_setup_user()
{
  local i

  : ${DOCKER_ACCOUNTS_CREATE_USER=1}
  : ${DOCKER_ACCOUNTS_CREATE_GROUPS=1}
  : ${DOCKER_ACCOUNTS_POSIX_GROUPS=${DOCKER_ACCOUNTS_CREATE_GROUPS}}

  : ${DOCKER_USERNAME=user}
  : ${DOCKER_UID=1000}
  : ${DOCKER_GROUP_NAMES=user}
  : ${DOCKER_GIDS=1000}
  : ${DOCKER_HOME=/home/${DOCKER_USERNAME}}

  # Convert to arrays
  DOCKER_GIDS=(${DOCKER_GIDS[@]})
  DOCKER_GROUP_NAMES=(${DOCKER_GROUP_NAMES[@]})

  if [ "${DOCKER_ACCOUNTS_POSIX_GROUPS}" == "1" ]; then
    # Remove non-posix characters
    for i in "${!DOCKER_GROUP_NAMES[@]}"; do
      DOCKER_GROUP_NAMES[$i]="$(sed 's|[^0-9a-zA-Z._ -]||g
                                     # in cases where 100% of characters were non-posix
                                     # simply name the group "group"
                                     s|^ *$|group|' <<< "${DOCKER_GROUP_NAMES[$i]}")"
    done
  fi


  if [ "${DOCKER_ACCOUNTS_CREATE_USER}" == "1" ]; then
    add_user ${DOCKER_USERNAME} ${DOCKER_UID} ${DOCKER_GIDS[0]} "${DOCKER_HOME}"

    mkdir -p "${DOCKER_HOME}"
    chown ${DOCKER_UID}:${DOCKER_GIDS[0]} "${DOCKER_HOME}"
  fi

  if [ "${DOCKER_ACCOUNTS_CREATE_GROUPS}" == "1" ]; then
    local group
    local gshadow
    read_group_data

    LINUX_ACCOUNTS_AUTOSAVE=0 add_group ${DOCKER_GROUP_NAMES[0]} ${DOCKER_GIDS[0]}

    local users
    users=(${DOCKER_USERNAME})
    for ((i=1; i<${#DOCKER_GIDS[@]}; i++)); do
      LINUX_ACCOUNTS_AUTOSAVE=0 add_group ${DOCKER_GROUP_NAMES[$i]} ${DOCKER_GIDS[$i]}
    done

    write_group_data
  fi
}

##****f* docker_entrypoint.bsh/retry_as_user
# NAME
#   retry_as_user - If the command fails, retry it as DOCKER_USERNAME
# USAGE
#   Try to run a command as the current user (root); if that fails, run the
#   command as DOCKER_USERNAME.
# INPUTS
#   $1 - The command to execute
# PARAMETERS
#   [DOCKER_USERNAME] - The username used to create the new user. Default: user
# AUTHOR
#   Andy Neff
##***
function retry_as_user()
{
  "${@}" 2>/dev/null || gosu "${DOCKER_USERNAME}" "${@}"
}

##****f* docker_entrypoint.bsh/docker_link_mounts
# NAME
#   docker_link_mounts - Create symlinks based on JUST_DOCKER_ENTRYPOINT_LINKS
# USAGE
#   Automatically called when docker_entrypoint.bsh is called. If
#   docker_entrypoint.bsh is sourced, then docker_link_mounts would need to be
#   called separately.
# DESCRIPTION
#   When docker_compose_override/generate_docker_compose_override processes
#   mounts, the desired mount will not be possible in some cases such as nfs
#   with squash root. Instead the base mount point is mounted into the
#   container and a symlink is created to link the desired locations. This
#   function creates these symlinks based on the // separated string
#   JUST_DOCKER_ENTRYPOINT_LINKS. e.g., "source//destination//source//destination".
# PARAMETERS
#   [JUST_DOCKER_ENTRYPOINT_LINKS] - // delimited string of symlinks to create,
#                                    e.g., "source//destination//source//destination"
#   [DOCKER_LINK_MOUNTS_FORCE] - Adds a -f to ln commands. Disabled by default.
#                                Set this flag to enable.
#   [DOCKER_LINK_MOUNTS_NOT_IN_MOUNTS] - Prevents making symlinks in mounted
#                                        subdirectories. This is not the default
#                                        docker behavior, so this feature is
#                                        disabled by default. Set this flag to
#                                        enable.
#   [DOCKER_USERNAME] - The username used to create the new user. Default: user
# AUTHOR
#   Andy Neff
##***
function docker_link_mounts()
{
  local options
  local x
  local y

  : ${DOCKER_USERNAME=user}

  # Short circuit in the case that JUST_DOCKER_ENTRYPOINT_LINKS is unset
  if ! declare -p JUST_DOCKER_ENTRYPOINT_LINKS &>/dev/null; then
    return 0
  fi

  local MIFS=${MIFS-:} # change to // when done
  # Convert to array, using // as separator. This means you can't have unclean
  # paths with // in them, but this is an acceptable limitation
  MIFS="${MIFS}" split_s JUST_DOCKER_ENTRYPOINT_LINKS ${JUST_DOCKER_ENTRYPOINT_LINKS+"${JUST_DOCKER_ENTRYPOINT_LINKS}"}

  if [ -n "${DOCKER_LINK_MOUNTS_FORCE+set}" ]; then
    options='-f'
  fi
  if [[ "${OSTYPE}" != darwin* ]]; then
    options="${options-} -T"
  fi

  local link_destinations=()
  for ((x=1; x<${#JUST_DOCKER_ENTRYPOINT_LINKS[@]}; x+=2)); do
    # copy to an array of just destinations
    link_destinations+=("${JUST_DOCKER_ENTRYPOINT_LINKS[$x]}")
  done

  # Sort the array
  # per sort's man page:
  # The locale specified by the environment affects sort order. Set LC_ALL=C
  # to get the traditional sort order that uses native byte values.
  # We need it in this order so that base directories come before subdirectories.
  y=()
  while IFS= read -r -d '' x || [ -n "${x}" ]; do
    y+=("${x}")
  done < <(MIFS='\\x00' join_a_out ${link_destinations+"${link_destinations[@]}"} | LC_ALL=C sort -u -z)
  link_destinations=(${y+"${y[@]}"})


  if [ -n "${DOCKER_LINK_MOUNTS_NOT_IN_MOUNTS+set}" ]; then
    # Filter out destinations that are subdirectories of another volume; these
    # links may fail anyway if the directory already exists. We also don't want
    # to make symlinks in host directories if we can help it. symlinks are
    # strictly worse than bind mounts; don't try to make them as capable.
    for x in ${!link_destinations[@]}; do
      for ((y=0; y<x; y++)); do
        if [ -n "${link_destinations[$y]+set}" ] && \
          [[ ${link_destinations[$x]} == ${link_destinations[$y]}/* ]]; then
          unset link_destinations[$x]
          break
        fi
      done
    done
  fi

  for y in ${!link_destinations[@]}; do
    # Last link wins; this matches docker-compose behavior
    for ((x=${#JUST_DOCKER_ENTRYPOINT_LINKS[@]}-2; x>=0; x-=2)); do
      if [ -n "${link_destinations[$y]+set}" ] && \
         [ "${JUST_DOCKER_ENTRYPOINT_LINKS[$((x+1))]}" == "${link_destinations[$y]}" ]; then
        retry_as_user mkdir -p "$(dirname "${JUST_DOCKER_ENTRYPOINT_LINKS[$((x+1))]}")"

        # Don't overwrite an existing file unless explicitly requested
        if ! retry_as_user test -e "${JUST_DOCKER_ENTRYPOINT_LINKS[$((x+1))]}" || \
           [ -n "${DOCKER_LINK_MOUNTS_FORCE+set}" ]; then
          # The gosu version covers the case when the link's destination is
          # in a subdirectory of another volume that is on an nfs mount with
          # squash root. NOTE the containing volume was previously symlink'd
          # into place via this symlink indirection.
          retry_as_user ln -s ${options-} "${JUST_DOCKER_ENTRYPOINT_LINKS[$x]}" "${JUST_DOCKER_ENTRYPOINT_LINKS[$((x+1))]}"
        fi
        break
      fi
    done
  done
}

##****f* docker_entrypoint.bsh/docker_setup_data_volumes
# NAME
#   docker_setup_data_volumes - Change permissions of data volumes to 777
# USAGE
#   Automatically called when docker_entrypoint.bsh is called. If
#   docker_entrypoint.bsh is sourced, then docker_setup_data_volumes would need
#   to be called separately.
# DESCRIPTION
#   When docker_compose_override/generate_docker_compose_override processes
#   mounts, it determines the list of internal data volumes, and passes them
#   to the container in JUST_DOCKER_ENTRYPOINT_INTERNAL_VOLUMES. This function
#   uses that variable to set all the directories' permissions to 777. This is
#   useful for when a data volume is just created and it only had root
#   permissions
# PARAMETERS
#   [JUST_DOCKER_ENTRYPOINT_INTERNAL_VOLUMES] - // delimited string of folders
#                                               corresponding to data volumes
#                                               e.g., "/tmp/test1///dev/shm/2"
#   [JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS] - // delimited string of folders
#                                            corresponding to folders in volumes
#                                            that should be owned by DOCKER_UID
#                                            and DOCKER_GIDS[0]
#   [DOCKER_UID] - The UID used to reown JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS.
#                  Default: 1000
# AUTHOR
#   Andy Neff
##***
function docker_setup_data_volumes()
{
  if [ -n "${JUST_DOCKER_ENTRYPOINT_INTERNAL_VOLUMES:+set}" ]; then
    local just_docker_entrypoint_internal_volumes
    MIFS='//' split_s just_docker_entrypoint_internal_volumes "${JUST_DOCKER_ENTRYPOINT_INTERNAL_VOLUMES}"
    chmod 777 "${just_docker_entrypoint_internal_volumes[@]}"
  fi

  if [ -n "${JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS:+set}" ]; then
    : ${DOCKER_UID=1000}

    local just_docker_entrypoint_internal_dirs
    MIFS='//' split_s just_docker_entrypoint_internal_dirs "${JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS}"
    local reown_dirs=()
    local d
    for d in "${just_docker_entrypoint_internal_dirs[@]}"; do
      if [ "$(stat -c %u "${d}")" != "${DOCKER_UID}" ]; then
        reown_dirs=(${reown_dirs+"${reown_dirs[@]}"} "${d}")
      fi
    done
    if [[ ${#reown_dirs[@]} != 0 ]]; then
      echo "Reowning: ${reown_dirs[@]}"
      chown -R "${DOCKER_UID}:" "${reown_dirs[@]}"
    fi
  fi
}

##****f* docker_entrypoint.bsh/docker_convert_paths
# NAME
#   docker_convert_paths - Remove double slash from environment variables
# USAGE
#   Automatically called when docker_entrypoint.bsh is called. If
#   docker_entrypoint.bsh is sourced, then docker_convert_paths would need
#   to be called separately.
# DESCRIPTION
#   Using docker on Windows has many complexities. This function fixes the case
#   MSYS2/MINGW/CYGWIN converts paths for you too aggressively. The official
#   solution from http://www.mingw.org/wiki/Posix_path_conversion is to use //
#   on Windows.
#
#   While this is annoying and ugly, it is usually harmless... However not
#   always harmless and can and does create errors sometimes with no good
#   solution.
#
#   Using MSYS_NO_PATHCONV only works on Git for Windows, and will end up
#   breaking a lot more than it fixes. This function will remove the //'s on
#   the docker side
# PARAMETERS
#   [JUST_NO_PATHCONV] - Regex expression for variable names that should not
#                        be converted. It is anticipated this will never be
#                        needed but in case there is an environment variable
#                        that validly contains //, putting its name in here
#                        will exclude it from the conversion. Remember, the
#                        pattern '' matches everything.
#   [LC_COLLATE] - Has significant affect on regex ranges. [a-z] and [A-Z] has
#                  most of both upper and lower cases in their range on
#                  en_US.utf-8, which is probably not the intended result.
#                  Use LC_COLLATE=C or POSIX to get a more basic result.
# EXAMPLE
#   JUST_1="this is a :// test" # Excluded from converted
#   JUST_2="dir1://dir2"        # Converted
#   JUST_3="this is // test"    # Excluded from converted
#   JUST_4="test // this"       # Not converted, doesn't match pattern
#   JUST_5=//dir1://dir2"       # Converted
#
#   JUST_NO_PATHCONV="JUST_1|JUST_3" docker_convert_paths # Run conversion
#   JUST_NO_PATHCONV="JUST_{1,3}" docker_convert_paths    # Same thing
# NOTES
#   Only checks exported variables, and does not work on arrays, which shouldn't
#   be exported in the first place
#
#   Pure Bash implementation should decrease any unnecessary forking.
# AUTHOR
#   Andy Neff
##***
function docker_convert_paths()
{
  local var
  local value
  for var in $(compgen -A export); do
    if ! [[ ${var} =~ ${JUST_NO_PATHCONV-nomatch^} ]]; then
      value="${!var}"
      #Check leading //
      if [ ${#value} -ge 2 ] && [ "${value:0:2}" == "//" ]; then
        value="${value:1}"
      fi
      # Replace for internal ://
      export "${var}=${value//:\/\//:/}"
    fi
  done
}

if [[ ${BASH_SOURCE[0]} == ${0} ]] || [[ $(basename ${BASH_SOURCE[0]}) == ${0} ]]; then
  set -eu
  docker_setup_user ${@+"${@}"} && \
  docker_link_mounts ${@+"${@}"} && \
  docker_setup_data_volumes
fi
