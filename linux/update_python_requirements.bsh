#!/usr/bin/env bash

set -eu

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/ask_question"
source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"

# Requires ca-certificates wget

: ${PIP2=pip2}
: ${PIP3=pip3}

: ${VERBOSE=0}

if [ "${VERBOSE}" == "0" ]; then
  exec 3>/dev/null
else
  exec 3>&2
fi

#****F* vsi/update_python_requirements.bsh
# NAME
#   update_python_requirements.bsh - Updates a requirements.txt file
# DESCRIPTION
#   In order to create reliable dockers and build environments, not only do we
#   need a requirements.txt file that lists all the dependencies for a project,
#   we need to track the version of every package and the version of every
#   dependency. Without this, doing a pip install on another day, may result in
#   different versions that may introduce or obfuscate bugs.
#
#   This requirements files can be generated by hand, but is a timely process,
#   so update_python_requirements.bsh will update all the versions for you.
# INPUTS
#   requirements_python2.txt/requirements_python3.txt
#     This file contains the normal list of requirements that are pulled down
#     using pip and updated accordingly
#   requirements_python2_custom.txt/requirements_python3_custom.txt
#     A place to put custom requirements, like non-pypi urls, or packages you
#     don't want to be automatically upgraded by this script. You should use
#     urls specific to a version or specify an exact version number for pypi
#     packages
# PARAMETERS
#   [PIP2] - pip executable used for python 2. Default: pip2
#   [PIP3] - pip executable used for python 3. Default: pip3
#   [PIP_BINARY_ONLY] - Comma separated list of python packages that are
#                       downloaded in binary form. In order for this script to
#                       work accurately, all packages should be downloaded by
#                       source. However, a few packages such as entrypoint and
#                       bash_kernel do not have source distributions on pip.
#                       This script must be manually told which packages to
#                       download as binary or else it fails.
#                       Default: entrypoints,bash_kernel
#   VERBOSE - outputs more to stderr instead of /dev/null. Default: 0
# OUTPUT
#   requirements_python2.txt/requirements_python3.txt
#     Updates and rewrites this file
#   requirements_python2_derived.txt/requirements_python3_derived.txt
#     Contains the list of every package, custom package, and their derived
#     requirements as well, including exact version numbers. This is the one
#     and only file you will need to use with pip install.
# NOTE
#   Because pip does not perform dependency resolution, you may need to modify
#   the exact version number of certain dependencies manually
# AUTHOR
#   Andy Neff
#***

# Comma separated list of binary only packages
: ${PIP_BINARY_ONLY="entrypoints,bash_kernel"}

#****f* update_python_requirements.bsh/get_packages
# NAME
#   get_packages - Get the full list of derived requirements for pip command
# INPUTS
#   $1... - arguments to `pip download` command. Usually -r requirements.txt, but
#           could be anything that results in downloading packages
# PARAMETERS
#   [PIP_BINARY_ONLY] - See vsi/update_python_requirements.bsh
#   [temp_dir] - Allows you to setup a permanent temp_dir to download artifacts
#                in. If you do not specify one, a new directory is created and
#                cleaned up with every call to get_packages. Set this env variable
#                to prevent this bottleneck in multiple calls to get_packages
# BUGS
#   A package path cannot contain spaces. URLs typically do not, they contain %20
#   but if a local path does, it will bug out. It is possible to change the regex
#   to s|Collecting ([^ =<>~!]+)[^\n(]*from ([^ \n]*)( \(from [^\n]*)?|\2|g but
#   this can also falsely match a line that looks like " (from <stuff>)", so I
#   chose to just not allow spaces, which should work for the intended use case.
# NOTES
#   I do NOT use the --pre option for any of the pip commands, so pre-releases
#   are not considered. The easiest way to add a pre-release is to use the
#   custom requirements file
# AUTHOR
#   Andy Neff
#***
function get_packages()
{
  local temp_dir="${temp_dir-}"
  if [ -z "${temp_dir:+set}" ]; then
    # setup a self cleaning temp dir. This will happen EVERY call to get_packages
    make_temp_dir
  fi
  : ${PIP=${PIP2}}
  ${PIP} download -v -d "${temp_dir}" "${@}" --no-binary :all: --only-binary "${PIP_BINARY_ONLY}" |
    #tee /dev/stderr |
    tee >(cat 1>&2) |
    # This is a nasty tee hack due to https://github.com/docker/docker/issues/31243
    # Work on macOS https://stackoverflow.com/a/24276470/4166604
    sed -En '# Add collecting and using lines to the buffer
             /^Collecting/H
             /^  Using version/H
             # When you hit Successfully downloaded <name>, you are at the end
             /^Successfully downloaded /{
             # Start processing the entire hold buffer
             x
             # Extract the url, making sure the word from is not in (), make
             # sure the name has no spaces, after the from <word> is possibly a
             # (from <blah>) block
            #s|Collecting [^ =<>~!]+[^\n(]*from ([^ \n]*)[^\n]*|\1@|g
          '$'s|Collecting [^ =<>~!]+[][:blank:][:alnum:]!"#$%&\')*+,-./:;<=>?@\\^_`[{}|~]*from ([[:graph:]\t]*)[[:print:][:blank:]]*|\\1@|g''
             # Else, extract the version from the next line, which is a Using
            #s|Collecting ([^ =<>~!]+)[^\n]*\n  Using version ([^ ]*)[^\n]*|\1@\2|g
             s|Collecting ([^ =<>~!]+)[[:print:][:blank:]]*\n  Using version ([^ ]*)[[:print:][:blank:]]*|\1@\2|g
             p
             }'
  # There are two types of "Collecting" lines, the special wheel case, and
  # Collecting Django==1.11.1 from https://pypi.python.org/packages/2b/2c/019d6d5f7ed2889082ed96f849bf462c57265087a3a568a19b0d4c53bc55/Django-1.11.1-py2.py3-none-any.whl
  # Collecting pytz (from Django==1.11.1)
  #   Using version 2017.2 (newest of versions: 2005.post0, 2009.post0, 2013.6, 2013.7, 2013.8, 2013.9, 2014.1, 2014.1.1, 2014.2, 2014.3, 2014.4, 2014.7, 2014.9, 2014.10, 2015.2, 2015.4, 2015.6, 2015.7, 2016.1, 2016.2, 2016.3, 2016.4, 2016.6, 2016.6.1, 2016.7, 2016.10, 2017.2)
}

#****f* update_python_requirements.bsh/write_requirement
# NAME
#   write_requirement - Write a requirement to the requirements file
# INPUTS
#   $1 - Filename of the requirements.txt file (can be called anything)
#   $2 - The software package, in "{name}@{version}" or "{name}" format.
# OUTPUT
#   Appends to $1
# EXAMPLE
#   write_requirement requirements.txt scipy@0.19.1
#   write_requirement requirements.txt matplotlib@
#   # Does not write a specific version
#
#   # This might not work well with other functions in
#   # update_python_requirements, but you can also
#   write_requirement requirements.txt Django>=1.11.0@
# AUTHOR
#   Andy Neff
#***
function write_requirement()
{
  package_name=${2%%@*}
  version=${2#*@}
  if [ "${version}" == "" ]; then
    echo "${package_name}" >> "$1"
  else
    echo "${package_name}==${version}" >> "$1"
  fi
}

#****f* update_python_requirements.bsh/update_requirements
# NAME
#   update_requirements - Updates all the packages in the requirements file
# INPUTS
#   $1 - Input filename of the requirements.txt file (can be called anything)
#   $2 - Output filename of the requirements.txt file (can be called anything)
#        Should not be the same as the input filename
#   $3... - Any additional arguments to `pip download` command
# OUTPUT
#   Appends to $1
# AUTHOR
#   Andy Neff
#***
function update_requirements()
{
  local input=$1
  local output=$2
  shift 2
  echo "Checking ${input}"
  for package in $(get_packages -r "${input}" ${@+"${@}"}); do
    write_requirement "${output}" "${package}"
  done 2>&3
}

#****f* update_python_requirements.bsh/update_main_requirements
# NAME
#   update_main_requirements - Updates all packages in the main requirements file
# INPUTS
#   $1 - Input filename of the requirements.txt file (can be called anything)
# OUTPUT
#   Replaces the $1 file
# AUTHOR
#   Andy Neff
#***
function update_main_requirements()
{
  if [ ! -f "$1" ]; then
    echo "Skipping $1, not found"
    return
  fi
  # Strip all the version numbers so that the latest will be found
  awk -F '[<=>]' '{print $1}' "$1" > "$1.new"
  mv "$1.new" "$1"

  : > "$1.new"

  update_requirements "$1" "$1.new" --no-deps

  # Can't use wc -l here because its buggy with blank lines---counts "newlines"
  # not lines
  if [ "$(grep -cv '^\s*$' "$1")" == \
       "$(grep -cv '^\s*$' "$1.new")" ]; then
    mv -f "$1.new" "$1"
  else
    echo "Something went wrong. Try enabling the VERBOSE flag."
    exit 1
  fi
}

#****f* update_python_requirements.bsh/update_derived_requirements
# NAME
#   update_derived_requirements - Updates the derived requirements file
# INPUTS
#   $1 - The main requirements file
#   $2 - The custom requirements file
#   $3 - The derived requirements file
# OUTPUT
#   Replaces the $3 file
# AUTHOR
#   Andy Neff
#***
function update_derived_requirements()
{
  local args=()
  echo "#Autogenerated file. Please run just update-python-requirements to update" > "$3"

  # If the first file exists
  if [ -f "${1}" ]; then
    # Process it
    args=("${1}" "${3}")
    # If the second file exists too
    if [ -f "${2}" ]; then
      # Process it at the same time
      args+=("-r" "${2}")
    fi
  # Else, if only the second file exists
  elif [ -f "${2}" ]; then
    # Process only the second file
    args=("${2}" "${3}")
  fi

  # If there are any arguments, then call update_requirements
  if [ "${#args[@]}" -gt 0 ]; then
    update_requirements "${args[@]}"
  fi
}

#****f* update_python_requirements.bsh/update_python_requirements
# NAME
#   update_python_requirements - Main update_python_requirements function
# PARAMETERS
#   files2/files3 - update_python_requirements uses these filenames:
#                     requirements_${filesX}.txt,
#                     requirements_${filesX}_custom.txt and
#                     requirements_${filesX}_derived.txt.
#                   This parameter allows you to change the filesX part when
#                   sourcing this file and calling this function directly
# AUTHOR
#   Andy Neff
#***
files2=(python2)
files3=(python3)

function update_python_requirements()
{
  local use_pip2=0
  local use_pip3=0

  local tmp=(${PIP2})

  local temp_dir="${temp_dir-}"
  if [ -z "${temp_dir:+set}" ]; then
    # setup a self cleaning temp dir. This will happen EVERY call to get_packages
    make_temp_dir
  fi

  if command -v "${tmp[0]}" &> /dev/null; then
    use_pip2=1
  fi
  tmp=(${PIP3})
  if command -v "${tmp[0]}" &> /dev/null; then
    use_pip3=1
  fi

  if (( ${use_pip2} )); then
    for f in ${files2+"${files2[@]}"}; do
      update_main_requirements "requirements_${f}.txt"
    done
  fi
  if (( ${use_pip3} )); then
    for f in ${files3+"${files3[@]}"}; do
      PIP=${PIP3} update_main_requirements "requirements_${f}.txt"
    done
  fi

  for f in ${files2+"${files2[@]}"} ${files3+"${files3[@]}"}; do
    if [ -f "requirements_${f}.txt" ]; then
      echo "### requirements_${f}.txt ###"
      cat "requirements_${f}.txt"
    fi
  done

  echo "(Hint: You can edit the files before saying yes)"
  ask_question "Do these requirements look ok?" requirements "y"
  if [ "${requirements}" == "0" ]; then
    exit 1
  fi

  if (( ${use_pip2} )); then
    for f in ${files2+"${files2[@]}"}; do
      PIP="${PIP2}" update_derived_requirements "requirements_${f}.txt" \
                                                "requirements_${f}_custom.txt" \
                                                "requirements_${f}_derived.txt"
    done
  fi

  if (( ${use_pip3} )); then
    for f in ${files3+"${files3[@]}"}; do
      PIP="${PIP3}" update_derived_requirements "requirements_${f}.txt" \
                                                "requirements_${f}_custom.txt" \
                                                "requirements_${f}_derived.txt"
    done
  fi
}

if [[ ${BASH_SOURCE[0]} == ${0} ]] || [[ $(basename ${BASH_SOURCE[0]}) == ${0} ]]; then
  update_python_requirements
  exit $?
fi