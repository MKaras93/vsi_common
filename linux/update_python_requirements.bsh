#!/usr/bin/env bash

source "$(dirname "${BASH_SOURCE[0]}")"/ask_question

#Requires ca-certificates wget

: ${PIP2=pip2}
: ${PIP3=pip3}

: ${VERBOSE=0}

if [ "${VERBOSE}" == "0" ]; then
  exec 3>/dev/null
else
  exec 3>&2
fi

#comma separated list of binary only packages
PIP_BINARY_ONLY="entrypoints,bash_kernel"

function get_packages()
{
  : ${PIP=${PIP2}}
  ${PIP} download -v -d /tmp "${@}" --no-binary :all: --only-binary "${PIP_BINARY_ONLY}" |
#    tee /dev/stderr |
    tee >(cat 1>&2) |
    #this is a nasty tee hack due to https://github.com/docker/docker/issues/31243
    sed -En '# Add collecting and using lines to the buffer
             /^Collecting/H
             /^  Using /H
             # When you hit Successfully downloaded <name>, you are at the end
             /^Successfully downloaded /{
             # Start processing the entire hold buffer
             x
             # Extract the url, making sure the word from is not in ()
             s|Collecting ([^ =<>~!]+)[^\n(]*from ([^\n]*)|\2|g
             # Else, extract the version from the next line, which is a Using
             s|Collecting ([^ =<>~!]+)[^\n]*\n  Using version ([^ ]*)[^\n]*|\1@\2|g
             p
             }'
  # There are two types of "Collecting" lines, the special wheel case, and 
  # Collecting Django==1.11.1 from https://pypi.python.org/packages/2b/2c/019d6d5f7ed2889082ed96f849bf462c57265087a3a568a19b0d4c53bc55/Django-1.11.1-py2.py3-none-any.whl
  # Collecting pytz (from Django==1.11.1)
  #   Using version 2017.2 (newest of versions: 2005.post0, 2009.post0, 2013.6, 2013.7, 2013.8, 2013.9, 2014.1, 2014.1.1, 2014.2, 2014.3, 2014.4, 2014.7, 2014.9, 2014.10, 2015.2, 2015.4, 2015.6, 2015.7, 2016.1, 2016.2, 2016.3, 2016.4, 2016.6, 2016.6.1, 2016.7, 2016.10, 2017.2)
}
#I do NOT use the --pre option for any of the pip commands, so pre-releases are
#not considered. The easiest way to add a pre-release is to use the custom
#requirements file

function write_requirement()
{ #filename package_info(form of name@version)
  package_name=${2%%@*}
  version=${2#*@}
  if [ "${version}" == "" ]; then
    echo "${package_name}" >> "$1"
  else
    echo "${package_name}==${version}" >> "$1"
  fi
}

function update_requirements()
{ # input_requirements_file output_requirements_file [other args]
  local input=$1
  local output=$2
  shift 2
  echo "Checking ${input}"
  for package in $(get_packages -r "${input}" ${@+"${@}"}); do
    write_requirement "${output}" "${package}"
  done 2>&3
}

function update_main_requirements()
{
  if [ ! -f "$1" ]; then
    echo "Skipping $1, not found"
    return
  fi
  #Strip all the version numbers so that the latests will be found
  awk -F '[<=>]' '{print $1}' "$1" > "$1.new"
  mv "$1.new" "$1"

  : > "$1.new"

  update_requirements "$1" "$1.new" --no-deps

  #Can't use wc -l here cause its buggy with blank lines, counting "newlines" not lines
  if [ "$(grep -cv '^\s*$' "$1")" == \
       "$(grep -cv '^\s*$' "$1.new")" ]; then
    mv -f "$1.new" "$1"
  else
    echo "Something went wrong"
    exit 1
  fi
}

function update_derived_requirements()
{ # main_requirements.txt custom_requirements.txt derived_requirements.txt
  echo "#Autogenerated file. Please run just update-python-requirements to update" > "$3"

  if [ -f "$2" ]; then
    update_requirements "$2" "$3"
  fi
  if [ -f "$1" ]; then
    update_requirements "$1" "$3"
  fi
}

files2=(python2)
files3=(python3)

function update_python_requirements()
{
  local use_pip2=0
  local use_pip3=0

  local tmp=(${PIP2})
  if command -v "${tmp[0]}" &> /dev/null; then
    use_pip2=1
  fi
  tmp=(${PIP3})
  if command -v "${tmp[0]}" &> /dev/null; then
    use_pip3=1
  fi

  if (( ${use_pip2} )); then
    for f in ${files2+"${files2[@]}"}; do
      update_main_requirements "requirements_${f}.txt"
    done
  fi
  if (( ${use_pip3} )); then
    for f in ${files3+"${files3[@]}"}; do
      PIP=${PIP3} update_main_requirements "requirements_${f}.txt"
    done
  fi

  for f in ${files2+"${files2[@]}"} ${files3+"${files3[@]}"}; do
    if [ -f "requirements_${f}.txt" ]; then
      echo "### requirements_${f}.txt ###"
      cat "requirements_${f}.txt"
    fi
  done

  echo "(Hint: You can edit the files before saying yes)"
  ask_question "Do these requirements look ok?" requirements "y"
  if [ "${requirements}" == "0" ]; then
    exit 1
  fi

  if (( ${use_pip2} )); then
    for f in ${files2+"${files2[@]}"}; do
      PIP="${PIP2}" update_derived_requirements "requirements_${f}.txt" \
                                                "requirements_${f}_custom.txt" \
                                                "requirements_${f}_derived.txt"
    done
  fi

  if (( ${use_pip3} )); then
    for f in ${files2+"${files3[@]}"}; do
      PIP="${PIP3}" update_derived_requirements "requirements_${f}.txt" \
                                                "requirements_${f}_custom.txt" \
                                                "requirements_${f}_derived.txt"
    done
  fi
}

if [[ ${BASH_SOURCE[0]} == ${0} ]] || [[ $(basename ${BASH_SOURCE[0]}) == ${0} ]]; then
  update_python_requirements
  exit $?
fi