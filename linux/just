#!/usr/bin/env bash

#*# just/just

#**
# ========
# J.U.S.T.
# ========
#
# .. bash:file:: just
#
# When working on a project, it often becomes necessary to run many long commands. Similar to how a makefile connects `targets` with a string of commands, `just` gives an easy way to create a set of targets to execute easily. Unlike a makefile, it has two key distinctions
#
# * It's not a makefile. Bash is easier than make for simple tasks
# * It works on Windows (when bash is installed via Git for Windows or similar), macOS (which uses bash 3.2) and Linux with no additional dependencies.
#
# .. rubric:: Features
#
# * Tab completion (:mod:`.just`)
# * Comment generated help
# * Subcommands
# * Executing multiple targets in one call
#
# .. seealso::
#
#   :mod:`Justfile`
#     Blah justfile
#
#   :mod:`.just`
#     Tab completion for bash
#
#**

#**
# .. bash:command:: help
#
# Print out basic help based on the comments it the Justfile. In order to achieve this, case statements and comments need to be structured in a specific way for the parser to pick up. The same mechanism is used by tab completion in ``bash``
#
# .. note::
#
#     Currently this does not work for all ``bash`` cases. A few bash patterns are matched to make this behavior working, since bash does not have source reflection.
#
# .. rubric:: Basic example:
#
# In the simplest case, a regular case pattern followed by ``)#`` (with optional spaces) will be picked up by :bash:func:`help`
#
# .. code-block:: bash
#
#     foo) # Runs the foo routine
#
# .. rubric:: Multiple targets at once:
#
# The pattern ``pattern1|pattern2...)#`` will also be parsed as a single help entry
#
# .. code-block:: bash
#
#     cat|dog) # Routine for cats and dogs
#
# .. rubric:: Multiple targets:
#
# You can actually add any of the other patterns as comment for the sole purpose of populating the help and tab completion
#
# .. code-block:: bash
#
#     # cat) # Comment just for cat
#     # dog) # Comment just for dog
#     cat|\
#     dog) # A comment here would be for both cat and dog
#
# .. rubric:: Subcommand/subtarget example:
#
# .. code-block:: bash
#
#     foo_cat) # Runs the foo routine for cat
#     foo_dog) # Runs the foo routine for dog
#
#**

#   Commenting extra help targets:
#     # foo_a) # Runs the foo routine for a
#     # foo_b) # Runs the foo routine for b
#     foo_*)
#     ## foo_c) # Runs the foo routine for c, but don't tell anyone
#   Long comment lines:
#     command) # To write a long help message, end the line in a backslash (\) \
#              # and start the next line with a # to continue the comment. \
#              # Can be as long as you want.
#   The foo_a and foo_b are added to tab complete and help, but using more than
#   one # ignores it all together. So foo_c is ignored
#
#   Advanced Expansion subtarget array:
#     MY_ARRAY=(cat dog)
#     # catch_{MY_ARRAY}) #Catch animal
#     catch_*)
#   Help, tab complete, etc. will automatically be expanded to cat and dog. Very
#   useful for DRY and for programmatically determined subtargets
# NOTES
#   The help message can only be one line long, but can be as long as needed
#
#   The same mechanism populates help and tab completion
# AUTHOR
#   Andy Neff
##***

##****id* just/JUST_PRELOAD
# NAME
#   JUST_PRELOAD - Pre-load a special source file before all other just files
# DESCRIPTION
#   This script is sourced before anything else loads.
#
#   In rare case that the project environment file is too late in the just
#   loading, use this file. It is suggested to set the value in the SETUPFILE,
#   which defaults to setup.env.
#
#   This is left around for debug purposes really, probably never needed.
# AUTHOR
#   Andy Neff
##***
if [ -e "${JUST_PRELOAD-}" ]; then
  source "${JUST_PRELOAD}"
fi

set -euE

##****id* just/JUST_VERBOSE
# NAME
#   JUST_VERBOSE - Set verbosity level of just execution
# DESCRIPTION
#   Useful to debug problems, especially in the just executable. Set to 1 for
#   basic bash verbose (set -v). Set to 2 for set -xv plus useful PS4
# AUTHOR
#   Andy Neff
##***
if [ "${JUST_VERBOSE-}" = 1 ]; then
  set -v
elif [ "${JUST_VERBOSE-}" = 2 ]; then
  PS4='+${BASH_SOURCE[0]}:${LINENO} '
  set -xv
fi

function print_error()
{
  local rv=$?
  local stack=''
  local line
  echo
  echo 'Call stack'
  echo '----------'
  local -i i=0
  while line=("$(caller $i)"); do
    stack+="$(sed $'s| |\t|;s| |\t|' <<< "${line}")"$'\n'
    ((++i))
  done
  column -c1 -s $'\t' -t <<< "${stack}"
  echo
  echo "$1: line $2: Returned $rv" >&2
  # echo
  # echo "External call stack"
  # i=0
  # while (( i < ${#BASH_SOURCE[@]} )); do
  #   echo "${BASH_LINENO[$i]} ${FUNCNAME[$i]} ${BASH_SOURCE[$i]}"
  #   ((++i))
  # done

}
trap 'print_error "${BASH_SOURCE[0]}" "${LINENO}"' ERR

##****id* just/JUST_IN_SCRIPT
# NAME
#   JUST_IN_SCRIPT - Unexported variable to indicated sources by just
# DESCRIPTION
#   Useful in other scripts for determining if they are being sourced by just or
#   not.
# USAGE
#   Currently one use of this is dual purposing a file, so that it behaves
#   differently when sourced by just or by a user on the prompts
# AUTHOR
#   Andy Neff
##***
JUST_IN_SCRIPT=1

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/just_functions.bsh"

setup_powershell ${@+"${@}"}

# Special cases that don't use JUSTFILE and run alone
if [ "${1-}" == "--version" ]; then
  echo "${0##*/} version ${JUST_VERSION}"
  exit 0
elif [ "${1-}" == "--new" ]; then
  "${VSI_COMMON_DIR}/linux/new_just" ${@+"${@}"}
  exit 0
fi

##****d* just/JUSTFILE
# NAME
#   JUSTFILE - Optional override variable for location of Justfile
# DESCRIPTION
#   The default just file that _just_load_justfile searches for is called
#   Justfile. In order to change this default behavior, the environment variable
#   JUSTFILE needs to be set so that just knows what file name to look for.
# USAGE
#   JUSTFILE must not be set in the project environment files, as it will not
#   have the desired effect. Instead, it should either be manually set in the
#   environment or set in the setup and wrap script
# SEE ALSO
#   just/_just_load_justfile, just/_just_find_justfile, just/Just_wrap,
#   new_just/SETUPFILE, new_just/JUSTFILE
# AUTHOR
#   Andy Neff
##***

#**
# ========
# Justfile
# ========
#
# .. module:: Justfile
#
# The file sourced by just. The primary purpose of the Justfile is to define the function caseify. caseify should try to match ``$1`` and the number of additional arguments used should be added to extra_args
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#     #!/usr/bin/false
#     source_environment_files "${CWD}/my_project_name.env"
#
#     function caseify()
#     {
#       local just_arg=$1
#       shift 1
#       case ${just_arg} in
#         foo) #ls foo files
#           ls
#           ;;
#         two) # Target with two arguments
#           echo $1 $2
#           extra_args+=2
#         group) # Two groups of args
#           get_args ${@+"${@}"}
#           echo ${args+"${args[@]}"}
#           get_additional_args ${@+"${@}"}
#           echo ${args+"${args[@]}"}
#         # When a target starts with an _, it is hidden and is not included in
#         # tab complete. It remains hidden from help unless a help comment is
#         # added
#         _hidden)
#           ;;
#         *)
#           defaultify "${just_arg}" ${@+"${@}"}
#           ;;
#       esac
#     }
#
# .. seealso::
#
#   :func:`source_environment_files`
#     Sources environment
#   :func:`get_extra_args`
#     Parses
#   :bash:func:`help`
#     Help test
#   :data:`JUSTFILE`
#     Sets :mod:`Justfile` filename to load
#
#**

: ${JUSTFILE=Justfile}
_just_load_justfile "${JUSTFILE}"

if [ "${JUSTFILE}" = "" ]; then
  echo "Can't find a suitable configuration file in this directory or any"
  echo "parent. Are you in the right directory?"
  echo
  echo "Supported filenames: \"Justfile\" or value of \${JUSTFILE}"
  exit 1
fi

justify ${@+"${@}"}
