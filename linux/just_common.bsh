#!/usr/bin/env false
# This file should be sourced, NOT run

#*# just/just_common

#**
# .. default-domain:: bash
#
# =====================
# Just Common Functions
# =====================
#
# .. file:: just_common
#
# .. env:: JUST_VERSION
#
# Version number of just
#
# .. rubric:: Description
#
# If the version number from the last time the just setup script was sourced
# and just do not match, a warning message will appear
#
# .. seealso::
#   :file:`JUST_SETUP_SCRIPT`
#
# .. rubric:: Author
#
# Andy Neff
#
#**

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"

##****d* just/JUST_VERSION

_last_just_version=${JUST_VERSION-}
export JUST_VERSION=0.0.7
   # If last just version was set and different
if [ -n "${_last_just_version:+set}" ] && \
   [ "${_last_just_version}" != "${JUST_VERSION}" ]; then
  echo "WARNING: The version of just (${JUST_VERSION}) appears to have changed" >&2
  echo "since last time (${_last_just_version})" >&2
  echo "You may want to source ${JUST_SETUP_SCRIPT-your setup script} again" >&2
  echo >&2
fi
unset _last_just_version

#**
#
# .. env:: JUST_SETUP_SCRIPT
#
# Name of the just setup script
#
# .. rubric:: Description
#
# When writing a setup script (typically called setup.env), :env:`JUST_SETUP_SCRIPT`
# can optionally be set to the name of the script that will be used in
# messages such as the version check.
#
# .. rubric:: Example
#
# Usually developers will source a simple script to setup just. This primarily
# includes adding just to the path and setting up tab complete:
#
# .. code-block:: bash
#
#     export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#     source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/external/vsi_common/env.bsh"
#
# This might also include adding plugins for tab-complete.
#
# .. code-block:: bash
#
#     JUST_HELP_FILES=("${VSI_COMMON_DIR}"/linux/just_git_functions.bsh)
#
# This is also a convenient place to slip in git hooks.
#
# .. code-block:: bash
#
#     #Create post-checkout hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-checkout"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#
#         if [ "\$1" != "\$2" ]; then
#           echo
#           echo "Don't forget to update your environment with the command: just sync"
#         fi
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#
#     #Create post-merge hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-merge"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#
#         echo
#         echo "Don't forget to update your environment with the command: just sync"
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#     unset _just_temp_filename
#
# .. rubric:: Author
#
# Andy Neff
#
#**

##****d* just/JUST_SETUP_SCRIPT
##***

##****f* just/_just_commands_from_file
##***

#**
#
# .. env:: _just_commands_from_file
#
# Parses Justfile for help comments on targets
#
# .. rubric:: Synopsis
#
# Look for all case statements with a comment at the end. It will also parse
# commented case statements that exist for the purpose of populating the help
#
# .. rubric:: Inputs
#
# **$1** - Filename of Justfile to be parsed
#
# .. seealso::
#   :file:`JUST_HELP_SEPARATOR` just/help
#
# .. rubric:: Author
#
# Andy Neff
#
#**

function _just_commands_from_file()
{
           # Segment into "command JUST_HELP_SEPARATOR comment"
  \sed -nE ':combine
            # These next 5 lines combine lines ending in \ and remove leading spaces on next line
            /\\$/{
              # Read and append next line
              N
              # If the pattern buffer matches the case pattern, ends in a
              # \ and the comment continues on the next line, then combine
              /^ *#? *[ ?*_0-9|a-zA-Z{}-]*\) *#.*\\\n *#/{
                # Combine the two lines, removing the extra #, replacing it
                # with a single space
                s| *\\\n *# *| |
                t combine
              }
              s|\\\n *||''
              t combine
            }
            s|^ *#? *([ ?*_0-9|a-zA-Z{}-]*[?*_0-9|a-zA-Z{}-]) *\) *# *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|
            # If there is a match, process it
            t process
            # Else do not even print it. This replaces a grep
            b noprint
            :process
            # Remove trailing spaces
            s| +$||
            :processloop
            # Converts aaa|bbb|ccc @#@ blah to aaa @#@ blah\nbbb @#@ blah\n...
            s/\|(.* '"${JUST_HELP_SEPARATOR}"' (.*))/ '"${JUST_HELP_SEPARATOR}"' \2'$'\\\n''\1/
            # Continue processing until no matches
            t processloop
            p
            :noprint' "${1}"
}

##****if* just/_just_subcommands_from_array
##***

#**
#
# .. rubric:: Synopsis
#
# Returns a non-unique list of commands that have subcommands from an array.
# This is not intended to line up with the input array
#
# .. rubric:: Input
#
# stdin - see Usage
#
# .. rubric:: Output
#
# stdout - prints newline separated list of commands
#
# .. rubric:: Usage
#
# .. code-block:: bash
#
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
#   _just_subcommands_from_array <<< "${parsed_help_a[*]}"
#
#**

function _just_subcommands_from_array()
{
  \sed -nE 's|^(_?[a-zA-Z0-9\-]+)_.*|\1|p'
}

##****f* just/_just_subtargets_from_array
##***

#**
#
# .. rubric:: Usage
#
# .. code-block:: bash
#
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
#
#   _just_subtargets_from_array ${TARGET} "${parsed_help_a[@]}"
#
# .. rubric:: Inputs
#
# **$1** - subcommand name
# **$2..N** - help_lines
#
# .. rubric:: Return Value
#
# just_subtargets - Adds to array
#
# .. rubric:: Author
#
# Andy Neff
#
#**

function _just_subtargets_from_array()
{
  local help_line
  local subcommand="${1}"
  shift 1

  for help_line in ${@+"${@}"}; do
    if [[ ${help_line} =~ ^${subcommand}_.* ]]; then
      help_line=${help_line%% *}
      just_subtargets+=("${help_line#*_}")
    fi
  done
}

##****f* just/_just_parse_helps
##***

#**
#
# .. env:: _just_parse_helps
#
# Parse help information out of Just files
#
# .. rubric:: Input
#
# **$1...** - List of Just files, including plugins
#
# .. rubric:: Output
#
# parsed_help_a - Array of help lines: "target ${JUST_HELP_SEPARATOR} message"
#
# .. rubric:: Author
#
# Andy Neff
#
#**

function _just_parse_helps()
{
  local filename
  local IFS=$'\n'
  local i
  local target
  local target_array
  parsed_help_a=()

  for filename in ${@+"${@}"}; do
    parsed_help_a+=($(_just_commands_from_file "${filename}"))
  done

  # Target expansion magic
  for i in "${!parsed_help_a[@]}"; do
    if [[ ${parsed_help_a[$i]} =~ (^.*_)\{(.*)\}(\ ${JUST_HELP_SEPARATOR}\ .*) ]]; then
      unset parsed_help_a[$i]
      target_array="${BASH_REMATCH[2]}[@]"
      target_array=(${!target_array+"${!target_array}"})
      for target in "${target_array[@]}"; do
        parsed_help_a+=("${BASH_REMATCH[1]}${target}${BASH_REMATCH[3]} ${target}")
      done
    fi
  done
}

##****f* just/_just_load_justfile
##***

#**
#
# .. env:: _just_load_justfile
#
# Convenience function for finding and loading Justfile
#
# .. rubric:: Synopsis
#
# Loads the Justfile if it exists
#
# .. rubric:: INPUTS
#
# **$1** - The Justfile filename
#
# .. rubric:: SWITCHES
#
# :env:`JUST_DRYRUN_SOURCE` - For internal use, can replace the source command (with
# say :) to disable sourcing the Justfile
#
# .. rubric:: Author
#
# Andy Neff
#
#**

function _just_load_justfile()
{
  local file_matches=()
  if [ -f "${1}" ]; then
    file_matches=("${1}")
  else
    parent_find_files "${1}"
  fi

  if [ "${#file_matches[@]}" -gt 0 ] && [ -f "${file_matches[0]}" ]; then
    JUST_HELP_FILES+=("${file_matches[0]}")
    ${JUST_DRYRUN_SOURCE-source} "${file_matches[0]}"
  else
    echo "Can't find a suitable configuration file in this directory or any" >&2
    echo "parent. Are you in the right directory?" >&2
    echo >&2
    echo "Supported filenames: \"Justfile\" or value of \${JUSTFILE}" >&2
    echo >&2
  fi
}

##****f* just_plugins/_just_get_plugins()
##***

#**
#
# .. env:: _just_get_plugins()
#
# .. rubric:: Inputs
#
# **[$1]** - Default directory to look for JUST_PLUGIN_FILE in
#
# .. rubric:: Parameters
#
# :env:`[JUST_PLUGIN_FILE]` - Override the name of the just plugins file.
#                        Default: .justplugins
#
# .. rubric:: Output
#
# :env:`JUST_PLUGINS` - (Possibly empty) array of plugins filenames
#
# NOTES
#   _just_get_plugins adds to JUST_PLUGINS if it already exists. If you want to
#   replace JUST_PLUGINS, unset JUST_PLUGINS before calling _just_get_plugins.
#
# .. seealso::
#   :file:`just/just_plugins` just_plugins/.justplugins
#
# .. rubric:: Author
#
# Andy Neff
#
#**

function _just_get_plugins()
{
  local line
  local JUST_PLUGIN_FILE=${JUST_PLUGIN_FILE:-.justplugins}
  local base_dir=${1-.}

  # Set JUST_PLUGINS to an empty array if it doesn't exist already
  if ! \declare -p JUST_PLUGINS &>/dev/null; then
    JUST_PLUGINS=()
  fi

  # Prepend the directory if it doesn't exist
  if [ ! -f "${JUST_PLUGIN_FILE}" ]; then
    JUST_PLUGIN_FILE="${base_dir}/${JUST_PLUGIN_FILE}"
  fi

  # Make base_dir absolute
  if [ "${base_dir:0:1}" != "/" ]; then
    base_dir="$(cd "${base_dir}"; pwd)"
  fi

  # Read in the plugin file
  if [ -f "${JUST_PLUGIN_FILE}" ]; then
    while IFS='' \read -r line || [ -n "${line}" ]; do
      # Skip blank lines
      if [[ ${line} =~ ^[[:blank:]]*$ ]]; then
        continue
      fi
      # Skip comments
      if  [[ ${line} =~ ^[[:blank:]]*# ]]; then
        continue
      fi

      if [ "${line:0:1}" != "/" ]; then
        line="${base_dir}/${line}"
      fi

      JUST_PLUGINS+=("${line}")
    done < "${JUST_PLUGIN_FILE}"
  fi
}
