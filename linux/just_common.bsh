#!/usr/bin/env false
#This file should be sourced, NOT run

#****if* just/_just_find_justfile
# NAME
#   _just_find_justfile -- Find the Justfile
# DESCRIPTION
#   Searches for the Justfile to load. It starts by checking the current 
#   directory, and goes up. Just like git searches for a .git directory
# INPUTS
#   $1 - The name of the files being searched for, typically: Justfile
# RETURN VALUE
#   echoes out the filename if found, else nothing
# AUTHOR
#   Andy Neff
#***
_just_find_justfile()
{
  local just_tmp_last_node=
  local just_tmp_stat_command=
  #speed improvement: if it's right there, echo it out right away
  if [ -f "${1}" ]; then
    echo "./${1}"
    return
  fi
  #else search for the file
  if [ "$(\uname)" == "Darwin" ]; then
    just_tmp_stat_command="stat -f %d:%i ."
  else
    just_tmp_stat_command="stat -c %d:%i ."
  fi
  \pushd . > /dev/null
  while [ "${just_tmp_last_node}" != "$(\eval ${just_tmp_stat_command})" ]; do
    if [ -f "${1}" ]; then
      \echo "$(\cd "$(\dirname "${1}")"; \pwd)/$(\basename "${1}")"
      break
    fi
    just_tmp_last_node=$(\eval ${just_tmp_stat_command})
    \cd ..
  done
  \popd > /dev/null
}

#****if* just/_just_get_cases
# NAME
#   _just_get_cases -- Parse an in memory function for case switch values
# DESCRIPTION
#   Function to get all the cases from a function in memory.
# INPUTS
#   $1 - The name of the function being parsed
# RETURN VALUE
#   echoes out a newline delimited list of all the case values that had comments
# AUTHOR
#   Andy Neff
#***
_just_get_cases()
{
  # Cat a function on stdout
  \type "${@}" |
  #Don't print, match case switch statements
  #if pattern matched, print, else don't
  #It printing, all pipes are converted to ' | ' despite spaces in original file
  #convert these to newlines
  \sed -nE 's# *([a-zA-Z0-9_| \-]+)\).*#\1#
            t print
            b noprint
            :print
            s# \| #\n#g
            p
            :noprint'
}

#****if* just/_just_get_subcommands
# NAME
#   _just_get_subcommands -- Searches a function in memory for subcommands
# DESCRIPTION
#   Gets all the subcommands from a function in memory.
# INPUTS
#   $1 - The name of the function being parsed
# RETURN VALUE
#   echoes out a newline delimited list of all the case values that had comments
# AUTHOR
#   Andy Neff
#***
_just_get_subcommands()
{ 
  just_subcommands+=($(_just_get_cases "${@}" |
                       # Grep and sed out that subcommand names
                       \sed -nE 's|^([a-zA-Z0-9\-]+)_[a-zA-Z0-9_\-]+|\1|
                                 t print
                                 b noprint
                                 :print
                                 s| |\n|g
                                 p
                                 :noprint' |
                       # Sort and get unique listing
                       \sort -u))
}

#****if* just/_just_get_subtargets
# NAME
#   _just_get_subtargets -- Searches a function in memory for subtargets
# DESCRIPTION
#   Gets all the subtargets for a particular subcommand from a function in memory.
# INPUTS
#   $1 - The name of the subcommand to list all the subtargets of
#   $2 - The name of the function being parsed
# RETURN VALUE
#   just_subtargets is set to an array of subtargets
# NOTES
#   just_subtargets is not cleared on purpose, in case you need to parse multiple
#   functions. Remember to set
#       just_subtargets=()
#   when you want to get a clean list of subtargets
# AUTHOR
#   Andy Neff
#***
_just_get_subtargets()
{
  local subcommand="$1"
  shift 1
  just_subtargets+=($(_just_get_cases "${@}" |
                      # filter out only the matching subcommand and print targets
                      \sed -nE 's|^'"${subcommand}"'_([a-zA-Z0-9\-\_]+)|\1|
                                t print
                                b noprint
                                :print
                                p
                                :noprint'))
}
