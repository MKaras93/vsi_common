#!/usr/bin/env false
#This file should be sourced, NOT run

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"

#****d* just/JUST_VERSION
# NAME
#   JUST_VERSION - Version number of just
# DESCRIPTION
#   If the version number from the last time the just setup script was sourced
#   and just do not match, a warning message will appear
# SEE ALSO
#   just/JUST_SETUP_SCRIPT
# AUTHOR
#   Andy Neff
#***
_last_just_version=${JUST_VERSION-}
export JUST_VERSION=0.0.4
   # If last just version was set and different
if [ -n "${_last_just_version:+set}" ] && \
   [ "${_last_just_version}" != "${JUST_VERSION}" ]; then
  echo "WARNING: The version of just (${JUST_VERSION}) appears to have changed" >&2
  echo "since last time (${_last_just_version})" >&2
  echo "You may want to source ${JUST_SETUP_SCRIPT-your setup script} again" >&2
  echo >&2
fi
unset _last_just_version

#****d* just/JUST_SETUP_SCRIPT
# NAME
#   JUST_SETUP_SCRIPT - Name of the just setup script
# DESCRIPTION
#   When writing a setup script (typically called setup.env), JUST_SETUP_SCRIPT
#   can optionally be set to the name of the script that will be used in
#   messages such as the version check.
# EXAMPLE
#   Usually developers will source a simple script to setup just. This primarily
#   includes adding just to the path and setting up tab complete:
#
#     export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#     source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/external/vsi_common/env.bsh"
#
#   This might also include adding plugins for tab-complete
#
#     JUST_HELP_FILES=("${VSI_COMMON_DIR}"/linux/just_git_functions.bsh)
#
#   This is also a convenient place to slip in git hooks
#
#     #Create post-checkout hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-checkout"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#
#         if [ "\$1" != "\$2" ]; then
#           echo
#           echo "Don't forget to update your environment with the command: just sync"
#         fi
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#
#     #Create post-merge hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-merge"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#
#         echo
#         echo "Don't forget to update your environment with the command: just sync"
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#     unset _just_temp_filename
# AUTHOR
#   Andy Neff
#***

#****f* just/_just_commands_from_file
# NAME
#   _just_commands_from_file - Parses Justfile for help comments on targets
# SYNOPSIS
#   Look for all case statements with a comment at the end. It will also parse
#   commented case statements that exist for the purpose of populating the help
# INPUTS
#   $1 - Filename of Justfile to be parsed
# SEE ALSO
#   JUST_HELP_SEPARATOR, just/help
# AUTHOR
#   Andy Neff
#***
function _just_commands_from_file()
{
           # Segment into "command JUST_HELP_SEPARATOR comment"
  \sed -nE ':combine
            # These next 5 lines combine lines ending in \ and remove leading spaces on next line
            /\\$/{
              # Read and append next line
              N
              # If the pattern buffer matches the case pattern, ends in a
              # \ and the comment continues on the next line, then combine
              /^ *#? *[ ?*_0-9|a-zA-Z{}-]*\) *#.*\\\n *#/{
                # Combine the two lines, removing the extra #, replacing it
                # with a single space
                s| *\\\n *# *| |
                t combine
              }
              s|\\\n *||''
              t combine
            }
            s|^ *#? *([ ?*_0-9|a-zA-Z{}-]*[?*_0-9|a-zA-Z{}-]) *\) *# *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|
            # If there is a match, process it
            t process
            # Else do not even print it. This replaces a grep
            b noprint
            :process
            # Remove trailing spaces
            s| +$||
            :processloop
            # Converts aaa|bbb|ccc @#@ blah to aaa @#@ blah\nbbb @#@ blah\n...
            s/\|(.* '"${JUST_HELP_SEPARATOR}"' (.*))/ '"${JUST_HELP_SEPARATOR}"' \2'$'\\\n''\1/
            # Continue processing until no matches
            t processloop
            p
            :noprint' "${1}"
}

#****if* just/_just_subcommands_from_array
# SYNOPSIS
#   Returns a non-unique list of commands that have subcommands from an array.
#   This is not intended to line up with the input array
# INPUT
#   stdin - see USAGE
# OUTPUT
#   stdout - prints newline separated list of commands
# USAGE
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
#   _just_subcommands_from_array <<< "${parsed_help_a[*]}"
#***
function _just_subcommands_from_array()
{
  \sed -nE 's|^(_?[a-zA-Z0-9\-]+)_.*|\1|p'
}

#****f* just/_just_subtargets_from_array
# USAGE
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
#
#   _just_subtargets_from_array ${TARGET} "${parsed_help_a[@]}"
# INPUTS
#   $1 - subcommand name
#   $2..N - help_lines
# RETURN VALUE
#   just_subtargets - Adds to array
# AUTHOR
#   Andy Neff
#***
function _just_subtargets_from_array()
{
  local help_line
  local subcommand="${1}"
  shift 1

  for help_line in ${@+"${@}"}; do
    if [[ ${help_line} =~ ^${subcommand}_.* ]]; then
      help_line=${help_line%% *}
      just_subtargets+=("${help_line#*_}")
    fi
  done
}

#****f* just/_just_parse_helps
# NAME
#   _just_parse_helps - Parse help information out of Just files
# INPUT
#   $1... - List of Just files, including plugins
# OUTPUT
#   parsed_help_a - Array of help lines: "target ${JUST_HELP_SEPARATOR} message"
# AUTHOR
#   Andy Neff
#***
function _just_parse_helps()
{
  local filename
  local IFS=$'\n'
  local i
  local target
  local target_array
  parsed_help_a=()

  for filename in ${@+"${@}"}; do
    parsed_help_a+=($(_just_commands_from_file "${filename}"))
  done

  # Target expansion magic
  for i in "${!parsed_help_a[@]}"; do
    if [[ ${parsed_help_a[$i]} =~ (^.*_)\{(.*)\}(\ ${JUST_HELP_SEPARATOR}\ .*) ]]; then
      unset parsed_help_a[$i]
      target_array="${BASH_REMATCH[2]}[@]"
      target_array=(${!target_array+"${!target_array}"})
      for target in "${target_array[@]}"; do
        parsed_help_a+=("${BASH_REMATCH[1]}${target}${BASH_REMATCH[3]} ${target}")
      done
    fi
  done
}

#****f* just/_just_load_justfile
# NAME
#   _just_load_justfile - Convenience function for finding and loading Justfile
# SYNOPSIS
#   Loads the Justfile if it exists
# INPUTS
#   $1 - The Justfile filename
# SWITCHES
#   JUST_DRYRUN_SOURCE - For internal use, can replace the source command (with
#   say :) to disable sourcing the Justfile
# AUTHOR
#   Andy Neff
#***
function _just_load_justfile()
{
  local file_matches=()
  parent_find_files "${1}"

  if [ "${#file_matches[@]}" -gt 0 ] && [ -f "${file_matches[0]}" ]; then
    JUST_HELP_FILES+=("${file_matches[0]}")
    ${JUST_DRYRUN_SOURCE-source} "${file_matches[0]}"
  else
    echo "Can't find a suitable configuration file in this directory or any" >&2
    echo "parent. Are you in the right directory?" >&2
    echo >&2
    echo "Supported filenames: \"Justfile\" or value of \${JUSTFILE}" >&2
    echo >&2
  fi
}

#****f* just_plugins/_just_get_plugins()
# NAME
#   _just_get_plugins()
# INPUTS
#   [$1] - Default directory to look for JUST_PLUGIN_FILE in
#   [JUST_PLUGIN_FILE] - Optional override the name of the just plugins file.
#                        Default: .justplugins
# OUTPUT
#   JUST_PLUGINS - (Possibly empty) array of plugins filenames
# NOTES
#   _just_get_plugins adds to JUST_PLUGINS if it already exists. If you want to
#   replace JUST_PLUGINS, unset JUST_PLUGINS before calling _just_get_plugins.
# SEE ALSO
#   just/just_plugins, just_plugins/.justplugins
# AUTHOR
#   Andy Neff
#***
function _just_get_plugins()
{
  local line
  local JUST_PLUGIN_FILE=${JUST_PLUGIN_FILE:-.justplugins}
  local base_dir=${1-.}

  # Set JUST_PLUGINS to an empty array if it doesn't exist already
  if ! \declare -p JUST_PLUGINS &>/dev/null; then
    JUST_PLUGINS=()
  fi

  # Prepend the directory if it doesn't exist
  if [ ! -f "${JUST_PLUGIN_FILE}" ]; then
    JUST_PLUGIN_FILE="${base_dir}/${JUST_PLUGIN_FILE}"
  fi

  # Make base_dir absolute
  if [ "${base_dir:0:1}" != "/" ]; then
    base_dir="$(cd "${base_dir}"; pwd)"
  fi

  # Read in the plugin file
  if [ -f "${JUST_PLUGIN_FILE}" ]; then
    while IFS='' \read -r line; do
      # Skip blank lines
      if [[ ${line} =~ ^[[:blank:]]*$ ]]; then
        continue
      fi
      # Skip comments
      if  [[ ${line} =~ ^[[:blank:]]*# ]]; then
        continue
      fi

      if [ "${line:0:1}" != "/" ]; then
        line="${base_dir}/${line}"
      fi

      JUST_PLUGINS+=("${line}")
    done < "${JUST_PLUGIN_FILE}"
  fi
}
