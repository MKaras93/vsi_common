#!/usr/bin/env bash

set -eu

# Redirect stderr to stdout, and stdout to 3; now the only way to write to
# stdout or stderr is to write to 3
exec 3>&1 # Copy stdout to 3
exec 1>&2 # Copy stderr to 1

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
if [ -f "${VSI_COMMON_DIR}/linux/ask_question" ]; then
  source "${VSI_COMMON_DIR}/linux/ask_question"
fi

#****F* just/new_just
# NAME
#   new_just - Create a new just project
# DESCRIPTION
#   There are many moving pieces to set up a working just project and use
#   all the features. Just getting started is hard, without knowing where to
#   start. This script will create all the files necessary to have a new
#   docker-compose based just project up and running.
# USAGE
#   By default, new_just will prompt the user for questions on the initial
#   setup parameters. Default values are supplied for all questions, and enter
#   can be pressed to accept all the defaults. All of the questions can be set
#   using environment variables, making them scriptable.
#
#   After new_just is called, a few git commands need to be called. This is not
#   done for you, in case it will break your existing repository. These
#   commands are printed out on stdout, while everything else is printed on
#   stderr, making them scriptable.
#
#   If any of the files written to exist, they are not overwritten, and a warning
#   message is printed out.
# SEE ALSO
#   new_just/PROJECT_DIR, new_just/PROJECT_NAME, new_just/PROJECT_PREFIX
#   new_just/REPO_NAME, new_just/JUSTFILE, new_just/WRAPFILE, new_just/SETUPFILE
#   new_just/VSI_DIR
# AUTHOR
#   Andy Neff
#***

echo "Setting up a new project to use J.U.S.T."
echo

#****d* new_just/PROJECT_DIR
# NAME
#   PROJECT_DIR - The main project directory
# DESCRIPTION
#   The project directory is typically the root directory of the main git
#   repository. This is where all the just files will be stored by default.
#
#   The value can be customized when prompted by new_just. The default value
#   is the current working directory. The question can be skipped by setting
#   the environment variable PROJECT_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_DIR="$(read -r -p "Project directory [${PWD}] " x; echo "$x")"}
if [ "${PROJECT_DIR}" == "" ]; then
  PROJECT_DIR="${PWD}"
else
  mkdir -p "${PROJECT_DIR}"
  PROJECT_DIR="$(cd "${PROJECT_DIR}"; pwd)"
fi

#****d* new_just/PROJECT_NAME
# NAME
#   PROJECT_NAME - Name of the just project being created
# DESCRIPTION
#   The PROJECT_NAME is used to set the project environment file name used by
#   source_environment_files. Specifically: ${PROJECT_DIR}/${PROJECT_NAME}.env
#   PROJECT_NAME is also used for for determining other default values.
#
#   The value can be customized when prompted by new_just. The default value
#   is basename of the PROJECT_DIR. The question can be skipped by setting the 
#   environment variable PROJECT_NAME to the desired value.
# SEE ALSO
#   just/source_environment_files
# AUTHOR
#   Andy Neff
#***
: ${PROJECT_NAME="$(read -r -p "Project name [$(basename "${PROJECT_DIR}")] " x; echo "$x")"}
if [ "${PROJECT_NAME}" == "" ]; then
  PROJECT_NAME="$(basename "${PROJECT_DIR}")"
fi


#****d* new_just/PROJECT_PREFIX
# NAME
#   PROJECT_PREFIX - The prefix of environment variables for this project
# DESCRIPTION
#   Used to set the value of JUST_PROJECT_PREFIX. Must contain only valid bash
#   variable-name characters: [A-Z0-9_]+
#
#   Does not need the trailing _ included, this will always be added when it is
#   used.
#
#   The value can be customized when prompted by new_just. The default value is
#   uppercase of the PROJECT_NAME. The question can be skipped by setting the
#   environment variable PROJECT_PREFIX to the desired value.
# SEE ALSO
#   just/JUST_PROJECT_PREFIX
# AUTHOR
#   Andy Neff
#***
default=$(echo "${PROJECT_NAME-}" | tr '[a-z]' '[A-Z]' | sed 's|[^A-Z0-9_]+||g')
: ${PROJECT_PREFIX="$(read -r -p "Project variable prefix [${default}] " x; echo $x)"}
if [ "${PROJECT_PREFIX}" == "" ]; then
  PROJECT_PREFIX=${default}
else
  PROJECT_PREFIX=$(echo "${PROJECT_PREFIX-}" | tr '[a-z]' '[A-Z]' | sed 's|[^A-Z0-9_]+||g')
fi



#****d* new_just/APP_NAME
# NAME
#   APP_NAME - The name of the test app generated
# DESCRIPTION
#   Used for the name of the first service populated for you
# AUTHOR
#   Andy Neff
#***
default=$(echo "${APP_NAME-someapp}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_.-]+||g')
: ${APP_NAME="$(read -r -p "Name of the example docker-compose app [${default}] " x; echo $x)"}
if [ "${APP_NAME}" == "" ]; then
  APP_NAME=${default}
else
  APP_NAME=$(echo "${APP_NAME-someapp}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_.-]+||g')
fi

APP_NAME_UPPER=$(echo "${APP_NAME}" | tr '[a-z]' '[A-Z]')

#****d* new_just/REPO_NAME
# NAME
#   REPO_NAME - Name of docker repository where images are stored
# DESCRIPTION
#   When docker images are built, they need to be named, or else the only way to
#   access them is inconveniently though sha256 checksums.
#
#   The REPO_NAME should be an untagged docker repository name. Tag names will
#   be added for each service. Docker image names must match the regex
#   [a-zA-Z0-9][a-zA-Z0-9_.-]* or else docker will error
#
#   The value can be customized when prompted by new_just. The default value is
#   lowercase of the PROJECT_NAME. The question can be skipped by setting the
#   environment variable REPO_NAME to the desired value.
# AUTHOR
#   Andy Neff
#***
default=$(echo "${PROJECT_NAME-}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_./-]+||g')
: ${REPO_NAME="$(read -r -p "Docker Repo for images [${default}] " x; echo $x)"}
if [ "${REPO_NAME}" == "" ]; then
  REPO_NAME=${default}
else
  REPO_NAME=$(echo "${REPO_NAME-}" | tr '[A-Z]' '[a-z]' | sed 's|[^a-z0-9_./-]+||g')
fi


#****d* new_just/JUSTFILE
# NAME
#   JUSTFILE - Name of the justfile used
# DESCRIPTION
#   The default just file in just is "Justfile". If this is changed, the only
#   way to inform just of this is by setting it in the SETUPFILE. This will be
#   added to the SETUPFILE by new_just if anything other than the default is
#   used.
#
#   The value can be customized when prompted by new_just. The default value
#   is Justfile. The question can be skipped by setting the environment variable
#   JUSTFILE to the desired value.
# SEE ALSO
#   new_just/SETUPFILE, just/Justfile
# AUTHOR
#   Andy Neff
#***
: ${JUSTFILE="$(read -r -p "Just file name [Justfile] " x; echo "$x")"}
if [ "${JUSTFILE}" == "" ]; then
  JUSTFILE="Justfile"
else
  JUSTFILE="$(basename ${JUSTFILE})"
fi


#****d* new_just/SETUPFILE
# NAME
#   SETUPFILE - Name of the setup file sourced to setup just environment
# DESCRIPTION
#   The setup file is used to make the minimal necessary changes to the
#   environment so that just works. This includes adding paths and setting a
#   few environment variables. This is meant to be as unobtrusive as possible.
#
#   This file needs to be sourced every time a new terminal session is opened.
#   The only time the setup script is not needed is when calling the WRAPFILE.
#
#   The value can be customized when prompted by new_just. The default value is
#   setup.env. The question can be skipped by setting the environment variable
#   SETUPFILE to the desired value.
# SEE ALSO
#   new_just/WRAPFILE
# AUTHOR
#   Andy Neff
#***
: ${SETUPFILE="$(read -r -p "Environment setup script file name [setup.env] " x; echo "$x")"}
if [ "${SETUPFILE}" == "" ]; then
  SETUPFILE="setup.env"
else
  SETUPFILE="$(basename ${SETUPFILE})"
fi

#****d* new_just/WRAPFILE
# NAME
#   WRAPFILE - The wrap filename that runs any command in the just environment
# DESCRIPTION
#   The wrap file can be used to run any command in the full just environment or
#   to enter a bash session in this environment.
#
#   The value can be customized when prompted by new_just. The default value is
#   wrap. The question can be skipped by setting the environment variable
#   WRAPFILE to the desired value.
# SEE ALSO
#   just/Just_wrap
# AUTHOR
#   Andy Neff
#***
: ${WRAPFILE="$(read -r -p "Wrap script file name [wrap] " x; echo "$x")"}
if [ "${WRAPFILE}" == "" ]; then
  WRAPFILE="wrap"
else
  WRAPFILE="$(basename ${WRAPFILE})"
fi

#****d* new_just/VSI_DIR
# NAME
#   VSI_DIR - Location of the vsi_common submodule
# DESCRIPTION
#   The vsi_common repository is necessary for virtually all of the just
#   capabilities. The correct way to deal with this is to add vsi_common as a
#   submodule for your main project. This tells just were this submodule is
#   located.
#
#   The value can be customized when prompted by new_just. The default value is
#   external/vsi_common. The question can be skipped by setting the environment
#   variable VSI_DIR to the desired value.
# AUTHOR
#   Andy Neff
#***
: ${VSI_DIR="$(read -r -p "VSI common module path [./external/vsi_common] " x; echo "$x")"}
if [ "${VSI_DIR}" == "" ]; then
  VSI_DIR="${PROJECT_DIR}/external/vsi_common"
else
  VSI_DIR="$(cd "${PROJECT_DIR}";
             mkdir -p "${VSI_DIR}";
             cd "${VSI_DIR}";
             pwd)"
fi

echo "Summary"
echo "======="
printf "%-40s | %-40s\n" "Project Name" "${PROJECT_NAME}"
printf "%-40s | %-40s\n" "Project Directory" "${PROJECT_DIR}"
printf "%-40s | %-40s\n" "Project prefix" "${PROJECT_PREFIX}"
printf "%-40s | %-40s\n" "App Name" "${APP_NAME}"
printf "%-40s | %-40s\n" "Just file" "${JUSTFILE}"
printf "%-40s | %-40s\n" "Environment setup script" "${SETUPFILE}"
printf "%-40s | %-40s\n" "Wrap script" "${WRAPFILE}"
printf "%-40s | %-40s\n" "Docker Repo" "${REPO_NAME}"
printf "%-40s | %-40s\n" "VSI Common Directory" "${VSI_DIR}"
echo
# Ask y/n question
if command -v ask_question &>/dev/null; then
  ask_question "Continue?" CONTINUE y
else
  if [ "${CONTINUE-1}" != "1" ]; then
    read -r -p "Press enter to continue"
  fi
  CONTINUE=1
fi

if [ "${CONTINUE}" != "1" ]; then
  exit 1
fi

# Setup done, start making the new environment

# RELATIVE_PATH="$(python -c "import os; print(os.path.relpath('${VSI_DIR}', '${PROJECT_DIR}'))")"
RELATIVE_PATH="$(perl -e "use File::Spec; print File::Spec->abs2rel('${VSI_DIR}','${PROJECT_DIR}');")"

# Make project dir
mkdir -p "${PROJECT_DIR}"
cd "${PROJECT_DIR}"

# Make wrap script
if [ ! -e "${WRAPFILE}" ]; then
  echo '#!/usr/bin/env bash' > "${WRAPFILE}"
  if [ "${JUSTFILE}" != "Justfile" ]; then
    echo "export JUSTFILE=${JUSTFILE}" >> "${WRAPFILE}"
  fi
  echo ': "$(dirname "${BASH_SOURCE[0]}")"
. "${_}"/'"${RELATIVE_PATH}"'/linux/Just_wrap "${_}"/'"${PROJECT_NAME}"'.env ${@+"${@}"}' >> "${WRAPFILE}"
else
  echo "${WRAPFILE} exists, skipping..."
fi

# Make setup script
if [ ! -e "${SETUPFILE}" ]; then
  echo 'export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
unset JUST_VERSION
source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/'"${RELATIVE_PATH}"'/env.bsh"' > "${SETUPFILE}"
  if [ "${JUSTFILE}" != "Justfile" ]; then
    echo "export JUSTFILE=${JUSTFILE}" >> "${SETUPFILE}"
  fi
else
  echo "${SETUPFILE} exists, skipping..."
fi


# Make the project settings file

if [ ! -e "${PROJECT_NAME}.env" ]; then
  echo 'JUST_PROJECT_PREFIX='"${PROJECT_PREFIX}"'
'"${PROJECT_PREFIX}"'_CWD="${CWD-"$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"}"

: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO='"${REPO_NAME}"'}

: ${'"${PROJECT_PREFIX}"'_HOME=/home/user}
: ${'"${PROJECT_PREFIX}"'_USERNAME=$(id -u -n)}
: ${'"${PROJECT_PREFIX}"'_UID=$(id -u)}
: ${'"${PROJECT_PREFIX}"'_GIDS=$(id -G)}
: ${'"${PROJECT_PREFIX}"'_GROUP_NAMES=$(group_names)}

: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR="${'"${PROJECT_PREFIX}"'_CWD}"}
: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER="/src"}

if [ "${VSI_OS}" = "linux" ]; then
  '"${PROJECT_PREFIX}"'_VOLUMES=("/tmp/.X11-unix:/tmp/.X11-unix:ro"
      ${'"${PROJECT_PREFIX}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_VOLUMES[@]}"})
fi

'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES=(
    "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}:${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER}"
    ${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES[@]}"})

' > "${PROJECT_NAME}.env"

else
  echo "${PROJECT_NAME}.env exists, skipping..."
fi

# Make default README
if [ ! -e "README.md" ]; then
  echo '## Getting started

```
. setup.env
just build
just run 
```

## Just usage:

```
source "'"${SETUPFILE}"'"
just help
```
' > README.md
else
  echo "README.md exists, skipping..."
fi

# Make Just file
if [ ! -e "${JUSTFILE}" ]; then
  echo '#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then # If being sourced
  set -euE
fi

source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/'"${WRAPFILE}"'"
cd "${'"${PROJECT_PREFIX}"'_CWD}"

source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
source "${VSI_COMMON_DIR}/linux/just_docker_functions.bsh"

function caseify()
{
  local just_arg=$1
  shift 1
  case ${just_arg} in
    build) # Build Docker image
      if [ "$#" -gt "0" ]; then
        Docker-compose "${just_arg}" ${@+"${@}"}
        extra_args+=$#
      else
        (justify build_recipes)
        Docker-compose build
      fi
      ;;
    run_'"${APP_NAME}"') # Run '"${APP_NAME}"' 1
      Just-docker-compose run '"${APP_NAME}"' ${@+"${@}"}
      extra_args+=$#
      ;;
    *)
      defaultify "${just_arg}" ${@+"${@}"}
      ;;
  esac
}

if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi
' > "${JUSTFILE}"
else
  echo "${JUSTFILE} exists, skipping..."
fi

mkdir -p docker

# Make default dockerfiles
if [ ! -e "docker/base_${APP_NAME}.Dockerfile" ]; then
  echo 'FROM vsiri/recipe:gosu as gosu
# Allow non-privileged to run gosu (remove this to take root away from user)
RUN chmod u+s /usr/local/bin/gosu

FROM vsiri/recipe:tini as tini
FROM vsiri/recipe:pipenv as pipenv

FROM debian:stretch

SHELL ["sh", "-euxvc"]

RUN build_deps="wget ca-certificates"; \
    apt-get update; \
    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends ${build_deps} nano; \
    wget -q https://www.vsi-ri.com/bin/deviceQuery; \
    DEBIAN_FRONTEND=noninteractive apt-get purge -y --autoremove ${build_deps}; \
    rm -rf /var/lib/apt/lists/*

COPY --from=tini /usr/local/bin/tini /usr/local/bin/tini
COPY --from=gosu /usr/local/bin/gosu /usr/local/bin/gosu

ADD '"${RELATIVE_PATH}"' /vsi
ADD docker/'"${APP_NAME}"'_entrypoint.bsh /
RUN chmod 755 /'"${APP_NAME}"'_entrypoint.bsh

ENTRYPOINT ["/usr/local/bin/tini", "/'"${APP_NAME}"'_entrypoint.bsh"]

CMD ["'"${APP_NAME}"'"]' > docker/base_${APP_NAME}.Dockerfile
else
  echo "docker/base_${APP_NAME}.Dockerfile exists, skipping..."
fi

if [ ! -e "docker/${APP_NAME}.Dockerfile" ]; then
  echo "FROM ${REPO_NAME}:base_${APP_NAME}" > "docker/${APP_NAME}.Dockerfile"
else
  echo "docker/${APP_NAME}.Dockerfile exists, skipping..."
fi

if [ ! -e "docker/${APP_NAME}_entrypoint.bsh" ]; then
  echo '#!/usr/bin/env bash

set -eu

if [ "${ALREADY_RUN_ONCE+set}" != "set" ]; then
  # create the user and associated groups and handle nfs symlinks
  bash -eu /vsi/linux/docker_entrypoint.bsh

  # Rerun entrypoint as user now, (skipping the root part via ALREADY_RUN_ONCE)
  ALREADY_RUN_ONCE=1 exec gosu ${DOCKER_USERNAME} $0 ${@+"${@}"}
fi

source "${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/wrap"
source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
filter_docker_variables

if [ "$1" == "'"${APP_NAME}"'" ]; then
  echo "Run '"${APP_NAME}"' here: ${@+${@}}"
else
  exec "${@}"
fi' > "docker/${APP_NAME}_entrypoint.bsh"
else
  echo "docker/${APP_NAME}_entrypoint.bsh exists, skipping..."
fi


# Make default docker-compose.yml
if [ ! -e "docker-compose.yml" ]; then
  echo 'version: "3.2"

services:
  base_'"${APP_NAME}"':
    build:
      context: .
      dockerfile: docker/base_'"${APP_NAME}"'.Dockerfile
    image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:base_'"${APP_NAME}"'
  '"${APP_NAME}"': &'"${APP_NAME}"'_anchor
    build:
      context: .
      dockerfile: docker/'"${APP_NAME}"'.Dockerfile
    # prevent different users from clobbering each others images
    image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:'"${APP_NAME}"'_${'"${PROJECT_PREFIX}"'_USERNAME}
    environment:
      # Variables for docker_entrypoint.bsh
      - DOCKER_UID=${'"${PROJECT_PREFIX}"'_UID}
      - DOCKER_GIDS=${'"${PROJECT_PREFIX}"'_GIDS}
      - DOCKER_GROUP_NAMES=${'"${PROJECT_PREFIX}"'_GROUP_NAMES}
      - DOCKER_USERNAME=user

      #- DOCKER_HOME=${'"${PROJECT_PREFIX}"'_HOME}

      - DISPLAY
    cap_add:
      - SYS_PTRACE # Useful for gdb
#    volumes:
#      - home-volume:${'"${PROJECT_PREFIX}"'_HOME} # home-volume should be overridable
  '"${APP_NAME}"'2:
    <<: *'"${APP_NAME}"'_anchor
#volumes:
#  home-volume:
' > "docker-compose.yml"
else
  echo "docker-compose.yml exists, skipping..."
fi

###
# Some final bookkeeping...
###

# Add executable permissions
chmod 755 "${JUSTFILE}" "${WRAPFILE}"

if [ ! -e .dockerignore ]; then
  echo '*' > .dockerignore
  echo '!docker' >> .dockerignore
  echo '!external/vsi_common' >> .dockerignore
fi

# Add .gitignore exceptions
if ! grep -q local.env .gitignore 2>/dev/null; then
  echo local.env >> .gitignore
fi
if ! grep -q local_post.env .gitignore 2>/dev/null; then
  echo local_post.env >> .gitignore
fi

if [ ! -e ".gitattributes" ]; then
  echo '#These file types are being explicitly set to linux line endings for windows.
#This is to allow windows user to edit and run these files inside a linux docker
#this list may need additions as time goes on
*.sh eol=lf
*.bsh eol=lf
*.py eol=lf
*.env eol=lf
wrap eol=lf
.justplugins eol=lf
' > .gitattributes
fi

# Remove dummy vsi_common dir to make way for submodule setup
rmdir -p "${VSI_DIR}" 2>/dev/null || :

# ****************************************************************************
# ****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****
# ****************************************************************************
echo 'Done!'
echo
echo
echo "To complete your git initialization:"
echo
echo "cd '${PROJECT_DIR}'"
if [ ! -e .git ]; then
  echo "git init ." >&3
fi
echo "git submodule add git@github.com:visionsystemsinc/vsi_common.git" \
                       "'${RELATIVE_PATH}'"  >&3
echo "git submodule update --init --recursive" >&3
echo "git add .gitattributes .gitignore .dockerignore .gitmodules README.md '${JUSTFILE}'" \
     "'${SETUPFILE}' '${WRAPFILE}' '${PROJECT_NAME}.env'" \
     "docker-compose.yml docker/${APP_NAME}.Dockerfile docker/${APP_NAME}_entrypoint.bsh" \
     "docker/base_${APP_NAME}.Dockerfile" >&3
echo "git commit -m 'Initial commit'"  >&3
echo
echo
echo
echo "To use your new just:"
echo
echo "cd '${PROJECT_DIR}'"
echo ". '${SETUPFILE}'"
echo "just help"
echo
echo "Get started with:"
echo
echo "just build"
echo "just run ${APP_NAME} bash"
