#!/usr/bin/env bash

# Usage:
#   curl -LO https://raw.githubusercontent.com/VisionSystemsInc/vsi_common/master/linux/new_just
#   bash ./new_just

set -eu

# Redirect stderr to stdout, and stdout to 3; now the only way to write to
# stdout or stderr is to write to 3
exec 3>&1 # Copy stdout to 3
exec 1>&2 # Copy stderr to 1

: ${VSI_COMMON_DIR="$(dirname "${BASH_SOURCE[0]}")/.."}
if [ -f "${VSI_COMMON_DIR}/linux/ask_question" ]; then
  source "${VSI_COMMON_DIR}/linux/ask_question"
else
  function ask_question()
  {
    if [[ $# > 2 ]]; then
      local default_response="$3"
    else
      local default_response=
    fi
    if [ "${!2=}" != "" ]; then
      local override=${!2}
    fi
    while true; do
      if [ "${override=}" != "" ]; then
        echo "$1 ${!2}"
        ans=$override
        override=""
      elif [ "$default_response" == "" ]; then
        read -r -p "$1 " ans
      else
        read -r -p "$1 ($default_response) " ans
      fi
      if [ "$ans" == "" ]; then
        ans="$default_response"
      fi
      case $ans in
        [Yy]* ) eval $2=1; break;;
        [Nn]* ) eval $2=0; break;;
        * ) echo "Please answer yes or no (y/n)";;
      esac
    done
  }
fi

# Use unwrapping echo so that this file is easier to read
if [ -f "${VSI_COMMON_DIR}/linux/uwecho.bsh" ]; then
  source "${VSI_COMMON_DIR}/linux/uwecho.bsh"
else
  function uwecho()
  {
    local line_number="$(caller)"
    local file_name="${line_number#* }"
    line_number="${line_number%% *}"
    local lines="$(echo -n ${@+"${@}"} | wc -l)"
    line_number=$((line_number-lines))
    local source_line="$(sed -n "${line_number}p" "${file_name}")"

    local spaces="$(echo -n "${source_line}" | sed -E 's|^( *uwecho +['"'"'"]?).*|\1|' | tr -d '\n' | wc -c)"
    local args=()
    while (( $# )); do
      args+=("$(sed '2,$s|^ \{'"${spaces}"'\}||' <<< "$1")")
      shift 1
    done
    echo ${args+"${args[@]}"}
  }
fi

# Use a bash relpath function
if [ -f "${VSI_COMMON_DIR}/linux/relpath" ]; then
  source "${VSI_COMMON_DIR}/linux/relpath"
else
  function relpath()
  {
    current="${1:+"$2"}"
    target="${1:-"$2"}"
    if [[ ${target} =~ ^\./*$ ]]; then
      target="/"
    fi
    if [[ ${current} =~ ^\./*$ ]]; then
      current="/"
    fi
    : "${current:="/"}"
    target="/$(sed -E 's|^/*||;s|/*$||' <<< "${target}")" >&2
    current="/$(sed -E 's|^/*||;s|/*$||' <<< "${current}")" >&2
    appendix="${target##/}"
    relative=''
    while appendix="${target#"$current"/}"
      [ "$current" != '/' ] && [ "$appendix" = "$target" ]; do
      if [ "$current" = "$appendix" ]; then
        relative="${relative:-.}"
        echo "${relative#/}"
        return 0
      fi
      current="${current%/*}"
      relative="$relative${relative:+/}.."
    done
    relative="$relative${relative:+${appendix:+/}}${appendix#/}"
    echo "$relative"
  }
fi

while (($#)); do
  arg="$1"
  shift 1
  case $arg in
    --help)
      echo "New Just Wizard usage"
      echo "====================="
      echo "  --help - prints this help"
      echo "  --project-dir DIR - Use dir as the project directory"
      echo "  --project-name NAME - Affects project env filename and defaults"
      echo "  --prefix PREFIX - Set variable prefix to use"
      echo "  --justfile FILE - Set Justfile name"
      echo "  --setupfile FILE - Set setup.env filename"
      echo "  --wrapfile FILE - Set wrap filename"
      echo "  --vsi-dir DIR - VSI common submodule dir"
      echo "  --[no-]use-vsi - Enable/[disable] using the vsi submodule"
      echo "  --[no-]use-docker - Enable/[disable] setting up docker"
      echo "  --[no-]use-pipenv - Enable/[disable] using pipenv in docker"
      echo "  --app APP - Application name for docker-compose service"
      echo "  --repo REPO - Docker repo name for compiled images"
      echo "  --defaults - use all defaults without prompting"
      echo "  --continue - Set to auto continue summary without prompting"
      echo
      exit 0
      ;;
    --defaults)
      USE_DEFAULTS=1
      : ${USE_VSI_COMMON=n}
      : ${USE_DOCKER=y}
      : ${USE_PIPENV=y}
      ;;
    --project-dir)
      PROJECT_DIR="$1"
      shift 1
      ;;
    --project-name)
      PROJECT_NAME="$1"
      shift 1
      ;;
    --prefix)
      PROJECT_PREFIX="$1"
      shift 1
      ;;
    --justfile)
      JUSTFILE="$1"
      shift 1
      ;;
    --setupfile)
      SETUPFILE="$1"
      shift 1
      ;;
    --wrapfile)
      WRAPFILE="$1"
      shift 1
      ;;
    --vsi-dir)
      VSI_DIR="$1"
      shift 1
      ;;
    --use-vsi)
      USE_VSI_COMMON=y
      ;;
    --no-use-vsi)
      USE_VSI_COMMON=n
      ;;
    --use-docker)
      USE_DOCKER=y
      ;;
    --no-use-docker)
      USE_DOCKER=n
      ;;
    --use-pipenv)
      USE_PIPENV=y
      ;;
    --no-use-pipenv)
      USE_PIPENV=n
      ;;
    --app)
      APP_NAME="$1"
      shift 1
      ;;
    --repo)
      REPO_NAME="$1"
      shift 1
      ;;
    --continue)
      CONTINUE=y
      ;;
    *)
      echo "Unknown argument: $arg"
      exit 1
      ;;
  esac
done

##****F* just/new_just
# NAME
#   new_just - Create a new just project
# DESCRIPTION
#   There are many moving pieces to set up a working just project and use
#   all the features. Just getting started is hard, without knowing where to
#   start. This script will create all the files necessary to have a new
#   docker-compose based just project up and running.
# USAGE
#   By default, new_just will prompt the user for questions on the initial
#   setup parameters. Default values are supplied for all questions, and enter
#   can be pressed to accept all the defaults. All of the questions can be set
#   using environment variables, making them scriptable.
#
#   After new_just is called, a few git commands need to be called. This is not
#   done for you, in case it will break your existing repository. These
#   commands are printed out on stdout, while everything else is printed on
#   stderr, making them scriptable.
#
#   If any of the files written to exist, they are not overwritten, and a warning
#   message is printed out.
# SEE ALSO
#   new_just/PROJECT_DIR, new_just/PROJECT_NAME, new_just/PROJECT_PREFIX
#   new_just/REPO_NAME, new_just/JUSTFILE, new_just/WRAPFILE, new_just/SETUPFILE
#   new_just/VSI_DIR
# AUTHOR
#   Andy Neff
##***

echo "Setting up a new project to use J.U.S.T."
echo

##****d* new_just/PROJECT_DIR
# NAME
#   PROJECT_DIR - The main project directory
# DESCRIPTION
#   The project directory is typically the root directory of the main git
#   repository. This is where all the just files will be stored by default.
#
#   The value can be customized when prompted by new_just. The default value
#   is the current working directory. The question can be skipped by setting
#   the environment variable PROJECT_DIR to the desired value.
# AUTHOR
#   Andy Neff
##***
default="${PWD}"
if [ "${USE_DEFAULTS-}" == "1" ]; then
  : ${PROJECT_DIR="${default}"}
fi

: ${PROJECT_DIR="$(read -r -p "Project directory (${default}) " x; echo "$x")"}
if [ "${PROJECT_DIR}" == "" ]; then
  PROJECT_DIR="${default}"
else
  mkdir -p "${PROJECT_DIR}"
  PROJECT_DIR="$(cd "${PROJECT_DIR}"; pwd)"
fi

##****d* new_just/PROJECT_NAME
# NAME
#   PROJECT_NAME - Name of the just project being created
# DESCRIPTION
#   The PROJECT_NAME is used to set the project environment file name used by
#   source_environment_files. Specifically: ${PROJECT_DIR}/${PROJECT_NAME}.env
#   PROJECT_NAME is also used for for determining other default values.
#
#   The value can be customized when prompted by new_just. The default value
#   is basename of the PROJECT_DIR. The question can be skipped by setting the
#   environment variable PROJECT_NAME to the desired value.
# SEE ALSO
#   just/source_environment_files
# AUTHOR
#   Andy Neff
##***
default="$(basename "${PROJECT_DIR}")"
if [ "${USE_DEFAULTS-}" == "1" ]; then
  : ${PROJECT_NAME="${default}"}
fi

: ${PROJECT_NAME="$(read -r -p "Project name ($(basename "${PROJECT_DIR}")) " x; echo "$x")"}
if [ "${PROJECT_NAME}" == "" ]; then
  PROJECT_NAME="${default}"
fi

##****d* new_just/PROJECT_PREFIX
# NAME
#   PROJECT_PREFIX - The prefix of environment variables for this project
# DESCRIPTION
#   Used to set the value of JUST_PROJECT_PREFIX. Must contain only valid bash
#   variable-name characters: [A-Z0-9_]+
#
#   Does not need the trailing _ included, this will always be added when it is
#   used.
#
#   The value can be customized when prompted by new_just. The default value is
#   uppercase of the PROJECT_NAME. The question can be skipped by setting the
#   environment variable PROJECT_PREFIX to the desired value.
# SEE ALSO
#   just/JUST_PROJECT_PREFIX
# AUTHOR
#   Andy Neff
##***
default=$(echo "${PROJECT_NAME-}" | tr '[a-z]' '[A-Z]' | sed -E 's|[^A-Z0-9_]+||g')
if [ "${USE_DEFAULTS-}" == "1" ]; then
  : ${PROJECT_PREFIX="${default}"}
fi

: ${PROJECT_PREFIX="$(read -r -p "Project variable prefix (${default}) " x; echo $x)"}
if [ "${PROJECT_PREFIX}" == "" ]; then
  PROJECT_PREFIX=${default}
else
  PROJECT_PREFIX=$(echo "${PROJECT_PREFIX-}" | tr '[a-z]' '[A-Z]' | sed -E 's|[^A-Z0-9_]+||g')
fi

##****d* new_just/JUSTFILE
# NAME
#   JUSTFILE - Name of the justfile used
# DESCRIPTION
#   The default just file in just is "Justfile". If this is changed, the only
#   way to inform just of this is by setting it in the SETUPFILE. This will be
#   added to the SETUPFILE by new_just if anything other than the default is
#   used.
#
#   The value can be customized when prompted by new_just. The default value
#   is Justfile. The question can be skipped by setting the environment variable
#   JUSTFILE to the desired value.
# SEE ALSO
#   new_just/SETUPFILE, just/Justfile
# AUTHOR
#   Andy Neff
##***
default=Justfile
if [ "${USE_DEFAULTS-}" == "1" ]; then
  : ${JUSTFILE="${default}"}
fi

: ${JUSTFILE="$(read -r -p "Just file name (Justfile) " x; echo "$x")"}
if [ "${JUSTFILE}" == "" ]; then
  JUSTFILE="${default}"
else
  JUSTFILE="$(basename "${JUSTFILE}")"
fi

##****d* new_just/USE_VSI_COMMON
# NAME
#   USE_VSI_COMMON - Flag to include vsi_common
# DESCRIPTION
#   vsi_common can either be included as a submodule, in which case setup.env
#   is needed, or the just executable needs to be installed and vsi_common is
#   not needed.
# AUTHOR
#   Andy Neff
##***
echo "If you do not include vsi_common, then all users will have to have"
echo "the just executable installed and on their path to use this project."
echo "(It also makes updating vsi_common features/bugs harder.)"
ask_question "Do you want to include the vsi_common submodule?" USE_VSI_COMMON n

##****d* new_just/SETUPFILE
# NAME
#   SETUPFILE - Name of the setup file sourced to setup just environment
# DESCRIPTION
#   The setup file is used to make the minimal necessary changes to the
#   environment so that just works. This includes adding paths and setting a
#   few environment variables. This is meant to be as unobtrusive as possible.
#
#   This file needs to be sourced every time a new terminal session is opened.
#   The only time the setup script is not needed is when calling the WRAPFILE.
#
#   The value can be customized when prompted by new_just. The default value is
#   setup.env. The question can be skipped by setting the environment variable
#   SETUPFILE to the desired value.
# SEE ALSO
#   new_just/WRAPFILE
# AUTHOR
#   Andy Neff
##***
if [ "${USE_VSI_COMMON}" = "1" ]; then
  default=setup.env
  if [ "${USE_DEFAULTS-}" == "1" ]; then
    : ${SETUPFILE="${default}"}
  fi

  : ${SETUPFILE="$(read -r -p "Environment setup script file name (setup.env) " x; echo "$x")"}
  if [ "${SETUPFILE}" == "" ]; then
    SETUPFILE="${default}"
  else
    SETUPFILE="$(basename "${SETUPFILE}")"
  fi

##****d* new_just/WRAPFILE
# NAME
#   WRAPFILE - The wrap filename that runs any command in the just environment
# DESCRIPTION
#   The wrap file can be used to run any command in the full just environment or
#   to enter a bash session in this environment.
#
#   The value can be customized when prompted by new_just. The default value is
#   wrap. The question can be skipped by setting the environment variable
#   WRAPFILE to the desired value.
# SEE ALSO
#   just/just_env
# AUTHOR
#   Andy Neff
##***
  default=wrap
  if [ "${USE_DEFAULTS-}" == "1" ]; then
    : ${WRAPFILE="${default}"}
  fi

  : ${WRAPFILE="$(read -r -p "Wrap script file name (wrap) " x; echo "$x")"}
  if [ "${WRAPFILE}" == "" ]; then
    WRAPFILE="${default}"
  else
    WRAPFILE="$(basename "${WRAPFILE}")"
  fi
fi

##****d* new_just/VSI_DIR
# NAME
#   VSI_DIR - Location of the vsi_common submodule
# DESCRIPTION
#   The vsi_common repository is necessary for virtually all of the just
#   capabilities. The correct way to deal with this is to add vsi_common as a
#   submodule for your main project. This tells just were this submodule is
#   located.
#
#   The value can be customized when prompted by new_just. The default value is
#   external/vsi_common. The question can be skipped by setting the environment
#   variable VSI_DIR to the desired value.
# AUTHOR
#   Andy Neff
##***
if [ "${USE_VSI_COMMON}" = "1" ]; then
  default="${PROJECT_DIR}/external/vsi_common"
  if [ "${USE_DEFAULTS-}" == "1" ]; then
    : ${VSI_DIR="${default}"}
  fi

  : ${VSI_DIR="$(read -r -p "VSI common module path (./external/vsi_common) " x; echo "$x")"}
  if [ "${VSI_DIR}" == "" ]; then
    VSI_DIR="${default}"
  else
    # Guarentee the path is clean, no .. or . or // in the name
    VSI_DIR="$(cd "${PROJECT_DIR}";
               if [ -e "${VSI_DIR}" ]; then
                 cd "${VSI_DIR}";
                 pwd;
               else
                 mkdir -p "${VSI_DIR}";
                 cd "${VSI_DIR}";
                 pwd;
                 cd "${PROJECT_DIR}";
                 rmdir "${VSI_DIR}";
               fi)"  # VSCode highlighter bug -->"
  fi
fi

## Docker Stuff

##****d* new_just/USE_DOCKER
# NAME
#   USE_DOCKER - Flag to turn on all the docker features
# AUTHOR
#   Andy Neff
##***
ask_question "Use docker?" USE_DOCKER y

##****d* new_just/USE_PIPENV
# NAME
#   USE_PIPENV - Flag to turn on setting up pipenv
# AUTHOR
#   Andy Neff
##***
ask_question "Use pipenv?" USE_PIPENV y

if [ "${USE_DOCKER}" = "1" ]; then
  #****d* new_just/APP_NAME
  # NAME
  #   APP_NAME - The name of the test app generated
  # DESCRIPTION
  #   Used for the name of the first service populated for you
  # AUTHOR
  #   Andy Neff
  #***
  default=$(echo "${APP_NAME-example}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_.-]+||g')
  if [ "${USE_DEFAULTS-}" == "1" ]; then
    : ${APP_NAME="${default}"}
  fi
  : ${APP_NAME="$(read -r -p "Name of the example docker-compose app (${default}) " x; echo $x)"}
  if [ "${APP_NAME}" == "" ]; then
    APP_NAME=${default}
  else
    APP_NAME=$(echo "${APP_NAME-example}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_.-]+||g')
  fi

  APP_NAME_UPPER=$(echo "${APP_NAME}" | tr '[a-z]' '[A-Z]')

  #****d* new_just/REPO_NAME
  # NAME
  #   REPO_NAME - Name of docker repository where images are stored
  # DESCRIPTION
  #   When docker images are built, they need to be named, or else the only way to
  #   access them is inconveniently though sha256 checksums.
  #
  #   The REPO_NAME should be an untagged docker repository name. Tag names will
  #   be added for each service. Docker image names must match the regex
  #   [a-zA-Z0-9][a-zA-Z0-9_.-]* or else docker will error
  #
  #   The value can be customized when prompted by new_just. The default value is
  #   lowercase of the PROJECT_NAME. The question can be skipped by setting the
  #   environment variable REPO_NAME to the desired value.
  # AUTHOR
  #   Andy Neff
  #***
  default=$(echo "${PROJECT_NAME-}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_./-]+||g')
  if [ "${USE_DEFAULTS-}" == "1" ]; then
    : ${REPO_NAME="${default}"}
  fi
  : ${REPO_NAME="$(read -r -p "Docker Repo for images (${default}) " x; echo $x)"}
  if [ "${REPO_NAME}" == "" ]; then
    REPO_NAME=${default}
  else
    REPO_NAME=$(echo "${REPO_NAME-}" | tr '[A-Z]' '[a-z]' | sed -E 's|[^a-z0-9_./-]+||g')
  fi
fi

echo "Summary"
echo "======="
printf "%-40s | %-40s\n" "Project Name" "${PROJECT_NAME}"
printf "%-40s | %-40s\n" "Project Directory" "${PROJECT_DIR}"
printf "%-40s | %-40s\n" "Project prefix" "${PROJECT_PREFIX}"
printf "%-40s | %-40s\n" "Just file" "${JUSTFILE}"
if [ "${USE_VSI_COMMON}" = "1" ]; then
  printf "%-40s | %-40s\n" "Environment setup script" "${SETUPFILE}"
  printf "%-40s | %-40s\n" "Wrap script" "${WRAPFILE}"
fi

printf "%-40s | %-40s\n" "Use docker" "${USE_DOCKER}"
printf "%-40s | %-40s\n" "Use pipenv" "${USE_PIPENV}"
printf "%-40s | %-40s\n" "Include vsi_common" "${USE_VSI_COMMON}"
if [ "${USE_DOCKER}" = "1" ]; then

  printf "%-40s | %-40s\n" "App Name" "${APP_NAME}"
  printf "%-40s | %-40s\n" "Docker Repo" "${REPO_NAME}"
  if [ "${USE_VSI_COMMON}" = "1" ]; then
    printf "%-40s | %-40s\n" "VSI Common Directory" "${VSI_DIR}"
  fi
fi
echo
# Ask y/n question
ask_question "Continue?" CONTINUE y

if [ "${CONTINUE}" != "1" ]; then
  exit 1
fi

# Setup done, start making the new environment

if [ "${USE_VSI_COMMON}" = "1" ]; then
  # RELATIVE_PATH="$(python -c "import os; print(os.path.relpath('${VSI_DIR}', '${PROJECT_DIR}'))")"
  # RELATIVE_PATH="$(perl -e "use File::Spec; print File::Spec->abs2rel('${VSI_DIR}','${PROJECT_DIR}');")"
  RELATIVE_PATH="$(relpath "${VSI_DIR}" "${PROJECT_DIR}")"
fi

# Make project dir
mkdir -p "${PROJECT_DIR}"
cd "${PROJECT_DIR}"

############
### wrap ###
############

# Helper to quote complicated names, adds '' for you, does not need extra
# quotes added to file
function quote()
{
  echo "'${1//\'/\'\"\'\"\'}'"
}

# Helper to quote complicated names that go in the blah part of "${x-blah}"
function quote_def()
{
  local x="${1//\"/\\\"}"
  echo "${x//\'/\"\'\"}"
}

if [ "${USE_VSI_COMMON}" = "1" ]; then
  if [ ! -e "${WRAPFILE}" ]; then
    echo   '#!/usr/bin/env bash' > "${WRAPFILE}"
    if [ "${JUSTFILE}" != "Justfile" ]; then
      echo "export JUSTFILE=$(quote "${JUSTFILE}")" >> "${WRAPFILE}"
    fi
    uwecho ': "$(\dirname "${BASH_SOURCE[0]}")"
            source "${VSI_COMMON_DIR:-"${_}"/'"$(quote_def "${RELATIVE_PATH}")"'}/linux/Just_wrap" "${_}"/'"$(quote "${PROJECT_NAME}")"'.env ${@+"${@}"}' >> "${WRAPFILE}"

  else
    echo "${WRAPFILE} exists, skipping..."
  fi

  #################
  ### setup.env ###
  #################

  if [ ! -e "${SETUPFILE}" ]; then
    uwecho 'export JUST_SETUP_SCRIPT="$(\basename "${BASH_SOURCE[0]}")"
            unset JUST_VERSION
            source "$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)/"'"$(quote "${RELATIVE_PATH}")"'/env.bsh' > "${SETUPFILE}"
    if [ "${JUSTFILE}" != "Justfile" ]; then
      echo "export JUSTFILE=$(quote "${JUSTFILE}")" >> "${SETUPFILE}"
    else
      echo "unset JUSTFILE" >> "${SETUPFILE}"
    fi
  else
    echo "${SETUPFILE} exists, skipping..."
  fi
fi

###################
### project.env ###
###################

if [ ! -e "${PROJECT_NAME}.env" ]; then

  uwecho   'JUST_PROJECT_PREFIX='"${PROJECT_PREFIX}"'
            '"${PROJECT_PREFIX}"'_CWD="${CWD-"$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"}"
            '  > "${PROJECT_NAME}.env"

  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho ': ${'"${PROJECT_PREFIX}"'_DOCKER_REPO='"${REPO_NAME}"'}

            : ${'"${PROJECT_PREFIX}"'_HOME=/home/user}
            : ${'"${PROJECT_PREFIX}"'_USERNAME="$(id -u -n)"}
            : ${'"${PROJECT_PREFIX}"'_UID=$(id -u)}
            : ${'"${PROJECT_PREFIX}"'_GIDS="$(id -G)"}
            : ${'"${PROJECT_PREFIX}"'_GROUP_NAMES="$(group_names)"}

            # This directory is added to the container using the docker-compose file. This mechanism
            # should only be used when the directory is garunteed to exist
            : ${'"${PROJECT_PREFIX}"'_SOURCE_DIR="${'"${PROJECT_PREFIX}"'_CWD}"}
            : ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER="/src"}

            # This directory is added to the container using '"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES
            # below. This mechanism is better when the directory doesn'"'"'t exist. The directory
            # will be created and owned properly
            : ${'"${PROJECT_PREFIX}"'_DATA_DIR="${'"${PROJECT_PREFIX}"'_SOURCE_DIR}/new-data"}
            : ${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER="/data"}

            if [ "${VSI_OS}" = "linux" ]; then
              '"${PROJECT_PREFIX}"'_VOLUMES=("/tmp/.X11-unix:/tmp/.X11-unix:ro"
                  ${'"${PROJECT_PREFIX}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_VOLUMES[@]}"})
            fi

            '"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES=(
                "${'"${PROJECT_PREFIX}"'_DATA_DIR}:${'"${PROJECT_PREFIX}"'_DATA_DIR_DOCKER}"
                ${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES+"${'"${PROJECT_PREFIX}"'_'"${APP_NAME_UPPER}"'_VOLUMES[@]}"})

            ###############################################################################
            # Non-'"${PROJECT_PREFIX}"' Settings
            ###############################################################################

            # Put variables that do not begin with '"${PROJECT_PREFIX}"' here.

            # Use this to add the user name to the docker-compose project name. This is
            # important when multiple users are using this docker-compose project on a
            # single host. This way all of the docker resources are prefixed with a unique
            # name and do not collide
            source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
            : ${COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${'"${PROJECT_PREFIX}"'_CWD}" "${'"${PROJECT_PREFIX}"'_USERNAME}")}

            ' >> "${PROJECT_NAME}.env"
  fi

else
  echo "${PROJECT_NAME}.env exists, skipping..."
fi

#################
### README.md ###
#################

if [ ! -e "README.md" ]; then
  uwecho   '## Getting started

            ``` ' > README.md

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    echo   "source $(quote "${SETUPFILE}")" >> README.md
  fi

  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho "just setup
            just run ${APP_NAME}" >> README.md
  else
    uwecho "just compile
            just run" >> README.md
  fi
  uwecho   '```

            ## Just usage:

            ```' >> README.md

  if [ "${USE_VSI_COMMON}" = "1" ]; then
    echo   "source $(quote "${SETUPFILE}")" >> README.md
  fi

  uwecho   'just help
            ```
            ' >> README.md
else
  echo     "README.md exists, skipping..."
fi

# Make Just file
if [ ! -e "${JUSTFILE}" ]; then
  if [ "${USE_DOCKER}" = "1" ]; then
    uwecho '#!/usr/bin/env bash

            if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then # If being sourced
              set -euE
            fi
            ' > "${JUSTFILE}"
    if [ "${USE_VSI_COMMON}" = "1" ]; then
      echo 'source "$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)/"'"$(quote "${WRAPFILE}")" >> "${JUSTFILE}"
    else
      echo 'source "${VSI_COMMON_DIR}/linux/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'"${PROJECT_NAME}"'.env' >> "${JUSTFILE}"
    fi
    uwecho 'cd "${'"${PROJECT_PREFIX}"'_CWD}"

            # Plugins
            source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
            source "${VSI_COMMON_DIR}/linux/just_docker_functions.bsh"
            source "${VSI_COMMON_DIR}/linux/just_git_functions.bsh"

            # Main function
            function caseify()
            {
              local just_arg=$1
              shift 1
              case ${just_arg} in
                build) # Build Docker image
                  if [ "$#" -gt "0" ]; then
                    Docker-compose "${just_arg}" ${@+"${@}"}
                    extra_args+=$#
                  else' >> "${JUSTFILE}"
    if [ "${USE_PIPENV}" = "1" ]; then
    uwecho '        (justify clean venv)
                    (justify build_recipes gosu tini vsi pipenv)
                    Docker-compose build
                    (justify _post_build)
                  fi
                  ;;
                _post_build)
                  image_name=$(docker create ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:'"${APP_NAME}"'_${'"${PROJECT_PREFIX}"'_USERNAME})
                  docker cp ${image_name}:/venv/Pipfile.lock "${'"${PROJECT_PREFIX}"'_CWD}/Pipfile.lock"
                  docker rm ${image_name}
                  ;;' >> "${JUSTFILE}"
    else
      echo '        (justify build_recipes gosu tini vsi)
                    Docker-compose build
                  fi
                  ;;' >> "${JUSTFILE}"
    fi
    uwecho '    run_'"${APP_NAME}"') # Run '"${APP_NAME}"' 1
                  Just-docker-compose run '"${APP_NAME}"' ${@+"${@}"}
                  extra_args+=$#
                  ;;

                setup) # Run any special command to set up the environment for the first \
                  # time after checking out the repo. Usually population of volumes/databases \
                  # go here.
                  (justify _sync)
                  ;;
                sync) # Synchronize the many aspects of the project when new code changes \
                      # are applied e.g. after "git checkout"
                  (justify _sync)
                  # Add any extra steps run when syncing when not installing
                  ;;
                _sync)
                  Docker-compose down
                  (justify git_submodule-update) # For those users who don'"'"'t remember!
                  (justify build)
                  ;;' >> "${JUSTFILE}"
    if [ "${USE_PIPENV}" = "1" ]; then
    uwecho '    clean_all) # Delete all local volumes
                  ask_question "Are you sure? This will remove packages not in Pipfile!" n
                  (justify clean venv)
                  ;;
                clean_venv) # Delete the virtual environment volume. The next container \
                            # to use this volume will automatically copy the contents from \
                            # the image.
                  if docker volume inspect "${COMPOSE_PROJECT_NAME}_venv" &> /dev/null; then
                    Docker volume rm "${COMPOSE_PROJECT_NAME}_venv"
                  else
                    echo "${COMPOSE_PROJECT_NAME}_venv already removed" >&2
                  fi
                  ;;' >> "${JUSTFILE}"
    fi
    uwecho '    *)
                  defaultify "${just_arg}" ${@+"${@}"}
                  ;;
              esac
            }

            if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi' >> "${JUSTFILE}"
  else
    uwecho '#!/usr/bin/env bash

            if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then # If being sourced
              set -euE
            fi

            ' > "${JUSTFILE}"
    if [ "${USE_VSI_COMMON}" = "1" ]; then
      echo 'source "$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)/'"${WRAPFILE}"'"' >> "${JUSTFILE}"
    else
      echo 'source "${VSI_COMMON_DIR}/linux/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'"${PROJECT_NAME}"'.env' >> "${JUSTFILE}"
    fi
    uwecho 'cd "${'"${PROJECT_PREFIX}"'_CWD}"

            function caseify()
            {
              local just_arg=$1
              shift 1
              case ${just_arg} in
                compile) # Build program
                  g++ hi.cpp -o hi
                  ;;
                run) # Run program
                  ./hi ${@+"${@}"}
                  extra_args+=$#
                  ;;
                *)
                  defaultify "${just_arg}" ${@+"${@}"}
                  ;;
              esac
            }

            if ! command -v justify &> /dev/null; then caseify ${@+"${@}"};fi' >> "${JUSTFILE}"
  fi
else
  echo "${JUSTFILE} exists, skipping..."
fi

if [ "${USE_PIPENV}" = "1" ]; then
  if [ ! -e "Pipfile" ]; then
    uwecho '[[source]]
            url = "https://pypi.org/simple"
            verify_ssl = true
            name = "pypi"

            [requires]
            # python_version = "*"

            [dev-packages]

            [packages]
            ' > Pipfile
  fi
  if [ ! -e "Pipfile.lock" ]; then
    uwecho '{
                "_meta": {
                    "hash": {
                        "sha256": "415dfdcb118dd9bdfef17671cb7dcd78dbd69b6ae7d4f39e8b44e71d60ca72e7"
                    },
                    "pipfile-spec": 6,
                    "requires": {},
                    "sources": [
                        {
                            "name": "pypi",
                            "url": "https://pypi.org/simple",
                            "verify_ssl": true
                        }
                    ]
                },
                "default": {},
                "develop": {}
            }' > Pipfile.lock
  fi
fi

if [ "${USE_DOCKER}" = "1" ]; then
  mkdir -p docker

  # Make default dockerfiles
  if [ ! -e "docker/${APP_NAME}.Dockerfile" ]; then
    uwecho   'FROM vsiri/recipe:gosu as gosu
              FROM vsiri/recipe:tini as tini
              FROM vsiri/recipe:vsi as vsi' > docker/${APP_NAME}.Dockerfile

    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho 'FROM vsiri/recipe:pipenv as pipenv
              # # Uncomment for GDAL
              # FROM vsiri/recipe:jq as jq

              FROM debian:stretch as dep_stage
              SHELL ["/usr/bin/env", "bash", "-euxvc"]

              # Install runtime dependencies
              RUN apt-get update; \
                  # Install runtime dependencies
                  # Note: run dependencies for other packages must also be included
                  DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
                    # # Uncomment for GDAL
                    # gdal-bin \
                    python3; \
                  rm -r /var/lib/apt/lists/*

              ENV \
                  # Move all virtualenvs to /venv
                  WORKON_HOME=/venv \
                  PIPENV_PIPFILE=/src/Pipfile \
                  # Stored the pipenv cache in /venv and packages are not recompiled
                  # at runtime when the build dependencies are no longer available
                  PIPENV_CACHE_DIR=/venv/cache \
                  # Needed for pipenv shell
                  PYENV_SHELL=/bin/bash \
                  # pipenv recommends that these env variables be set to en_US.UTF-8.
                  # C.UTF-8 seems to work. To generate en_US.UTF-8 locale follow
                  # https://stackoverflow.com/a/38553499/1771778
                  # Note, they do exist by default if you changed the base image to Centos/Fedora
                  LC_ALL=C.UTF-8 \
                  LANG=C.UTF-8

              COPY --from=pipenv /tmp/pipenv /tmp/pipenv
              RUN /tmp/pipenv/get-pipenv; rm -rf /tmp/pipenv || :

              FROM dep_stage as pipenv_cache

              # # Uncomment for GDAL
              # # Install build dependencies
              # RUN apt-get update; \
              #     DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
              #       libgdal-dev python3-dev g++ ; \
              #     rm -r /var/lib/apt/lists/*
              #
              # COPY --from=jq /usr/local/bin/jq /usr/local/bin/jq

              ADD Pipfile Pipfile.lock /src/
              # Packages can be added as dependencies to your project by either:
              # - "just run '"${APP_NAME}"'" and running "pipenv install {package}"
              #   e.g., "pipenv install scipy"
              # - Editing the Pipfile and adding lines to the [packages] section
              #   e.g., "scipy = '"'"'*'"'"'"

              # Here'"'"'s a more complicated example: GDAL
              # - GDAL has extra build dependencies. The apt-get pattern above will install
              #   these dependencies.
              # - GDAL'"'"'s build script needs some customization. The exports
              #   below accomplish this
              # - GDAL needs numpy installed before it is built, otherwise, numpy
              #   integration will not be compiled
              #
              # To test this out:
              # 1) Edit your Pipfile and add the following lines (or similar)
              #        gdal = "==2.1.0"
              #        numpy = "*"
              #    This will add the latest version of numpy and the version of
              #    gdal compatible with debian:stretch to your pipenv environment.
              #    Note: the version of the pypi package should match (as closely as
              #    possible) to the version of the GDAL-binary dependency (gdal-bin)
              # 2) Uncomment all the "Uncomment for GDAL" sections

              # # Uncomment for GDAL
              # RUN \
              #     # Gdal specific hacks
              #     export CPLUS_INCLUDE_PATH=/usr/include/gdal; \
              #     export C_INCLUDE_PATH=/usr/include/gdal; \
              #
              #     # Install the version of numpy specified in the Pipfiles first; after
              #     # numpy is installed, the other packages are installed into the cache. If
              #     # numpy is not locked yet, the version is an empty string and this still
              #     # works as expected
              #     numpy_version="$(jq --raw-output ".default.numpy.version // empty" "${PIPENV_PIPFILE}".lock)"; \
              #     pipenv install --keep-outdated numpy${numpy_version}; \
              #
              #     cp "${PIPENV_PIPFILE}".lock /venv; \
              #     rm -rf /src/* /tmp/pip*

              RUN \
                  # Install packages into the image
                  pipenv install --keep-outdated; \
                  # Copy the lock file, so that it gets exported to the repo after docker build
                  cp /src/Pipfile.lock /venv; \
                  # Cleanup and make way for the real /src that will be mounted at runtime
                  rm -rf /src/* /tmp/pip*

              FROM dep_stage' >> docker/${APP_NAME}.Dockerfile
    else
      uwecho '
              FROM debian:stretch
              SHELL ["/usr/bin/env", "bash", "-euxvc"]' >> docker/${APP_NAME}.Dockerfile

    fi

    uwecho   '
              # Example of installing packages
              RUN apt-get update; \
                  DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends python3; \
                  rm -rf /var/lib/apt/lists/*

              # Another typical example of installing a package
              # RUN build_deps="wget ca-certificates"; \
              #     apt-get update; \
              #     DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends ${build_deps}; \
              #     wget -q https://www.vsi-ri.com/bin/deviceQuery; \
              #     DEBIAN_FRONTEND=noninteractive apt-get purge -y --autoremove ${build_deps}; \
              #     rm -rf /var/lib/apt/lists/*

              COPY --from=tini /usr/local/bin/tini /usr/local/bin/tini

              COPY --from=gosu /usr/local/bin/gosu /usr/local/bin/gosu
              # Allow non-privileged to run gosu (remove this to take root away from user)
              RUN chmod u+s /usr/local/bin/gosu

              ' >> docker/${APP_NAME}.Dockerfile

    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho 'COPY --from=pipenv_cache /venv /venv' >> docker/${APP_NAME}.Dockerfile
    fi

    uwecho   '
              COPY --from=vsi /vsi /vsi
              ADD docker/'"${APP_NAME}"'_entrypoint.bsh /
              ADD '"${PROJECT_NAME}.env"' /src/

              ENTRYPOINT ["/usr/local/bin/tini", "/usr/bin/env", "--", "bash", "/'"${APP_NAME}"'_entrypoint.bsh"]
              # Does not require execute permissions, unlike:
              # ENTRYPOINT ["/usr/local/bin/tini", "/'"${APP_NAME}"'_entrypoint.bsh"]

              CMD ["'"${APP_NAME}"'"]' >> docker/${APP_NAME}.Dockerfile
  else
    echo     "docker/${APP_NAME}.Dockerfile exists, skipping..."
  fi

  if [ ! -e "docker/${APP_NAME}_entrypoint.bsh" ]; then
    uwecho   '#!/usr/bin/env bash

              set -eu

              source "${VSI_COMMON_DIR:-/vsi}/linux/just_env" "${'"${PROJECT_PREFIX}"'_SOURCE_DIR-/src}/'"${PROJECT_NAME}"'.env"

              if [ "${ALREADY_RUN_ONCE+set}" != "set" ]; then
                # create the user and associated groups and handle nfs symlinks

                # JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS will automatically chown
                # all files in volumes to match the user. If this takes too long
                # and you don'"'"'t need this feature, remove the ONE line, but leave
                # the docker_entrypoint.bsh call
                JUST_DOCKER_ENTRYPOINT_INTERNAL_DIRS="${JUST_DOCKER_ENTRYPOINT_INTERNAL_VOLUMES}" \
                /usr/bin/env bash /vsi/linux/docker_entrypoint.bsh

                # Rerun entrypoint as user now, (skipping the root part via ALREADY_RUN_ONCE)
                ALREADY_RUN_ONCE=1 exec gosu ${DOCKER_USERNAME} /usr/bin/env bash $0 ${@+"${@}"}
              fi

              function sudo()
              {
                gosu root ${@+"${@}"}
              }
              export -f sudo

              source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"
              # Remove duplicate '"${PROJECT_PREFIX}"'_*_DOCKER variables
              filter_docker_variables

              ' >> "docker/${APP_NAME}_entrypoint.bsh"

    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho '# default CMD
              if [ "$1" == "'"${APP_NAME}"'" ]; then
                pipenv shell
              elif [ "$1" == "nopipenv" ]; then
                shift 1
                exec "${@}"
              else
                exec pipenv run "${@}"
              fi' >> "docker/${APP_NAME}_entrypoint.bsh"
    else
      uwecho 'if [ "$1" == "'"${APP_NAME}"'" ]; then
                echo "Run '"${APP_NAME}"' here: ${@+${@}}"
              else
                exec "${@}"
              fi' >> "docker/${APP_NAME}_entrypoint.bsh"
    fi
  else
    echo     "docker/${APP_NAME}_entrypoint.bsh exists, skipping..."
  fi


  # Make default docker-compose.yml
  if [ ! -e "docker-compose.yml" ]; then
    uwecho 'version: "2.3"

            services:
              '"${APP_NAME}"': &'"${APP_NAME}"'_anchor
                build:
                  context: .
                  dockerfile: docker/'"${APP_NAME}"'.Dockerfile
                # prevent different users from clobbering each others images
                image: ${'"${PROJECT_PREFIX}"'_DOCKER_REPO}:'"${APP_NAME}"'_${'"${PROJECT_PREFIX}"'_USERNAME}
                environment:
                  # Variables for docker_entrypoint.bsh
                  - DOCKER_UID=${'"${PROJECT_PREFIX}"'_UID}
                  - DOCKER_GIDS=${'"${PROJECT_PREFIX}"'_GIDS}
                  - DOCKER_GROUP_NAMES=${'"${PROJECT_PREFIX}"'_GROUP_NAMES}
                  - DOCKER_USERNAME=user

                  #- DOCKER_HOME=${'"${PROJECT_PREFIX}"'_HOME}

                  - DISPLAY
            #     cap_add:
            #       - SYS_PTRACE # Useful for gdb
                volumes:
                  - type: bind
                    source: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR}
                    target: ${'"${PROJECT_PREFIX}"'_SOURCE_DIR_DOCKER}' > "docker-compose.yml"
    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho '      - type: volume
                      source: venv
                      target: /venv' >> "docker-compose.yml"
    fi
    uwecho '#       - type: volume
            #         source: home-volume
            #         target: ${'"${PROJECT_PREFIX}"'_HOME} # home-volume should be overridable
              '"${APP_NAME}"'2:
                <<: *'"${APP_NAME}"'_anchor' >> "docker-compose.yml"
    if [ "${USE_PIPENV}" = "1" ]; then
      uwecho 'volumes:
                venv:' >> "docker-compose.yml"
    else
      echo   '#   volumes:' >> "docker-compose.yml"
    fi
    echo     '#   home-volume:' >> "docker-compose.yml"
  else
    echo "docker-compose.yml exists, skipping..."
  fi

  if [ ! -e .dockerignore ]; then
    echo '*' > .dockerignore
    echo '!docker' >> .dockerignore
    if [ "${USE_VSI_COMMON}" = "1" ]; then
      echo '!'"${RELATIVE_PATH}" >> .dockerignore
    fi
    if [ "${USE_DOCKER}" = "1" ]; then
      echo '!'"${PROJECT_NAME}.env" >> .dockerignore
    fi

    if [ "${USE_PIPENV}" = "1" ]; then
      echo '!Pipfile' >> .dockerignore
      echo '!Pipfile.lock' >> .dockerignore
    fi
  fi


  if [ ! -e ".gitattributes" ]; then
    uwecho '#These file types are being explicitly set to linux line endings for windows.
            #This is to allow windows user to edit and run these files inside a linux docker
            #this list may need additions as time goes on
            *.sh eol=lf
            *.bsh eol=lf
            *.py eol=lf
            *.env eol=lf
            wrap eol=lf
            .justplugins eol=lf' > .gitattributes
  fi
else
  uwecho '#include <iostream>
          int main()
          {
            std::cout << "hello world!" << std::endl;
            return 0;
          }' > hi.cpp
fi

###
# Some final bookkeeping...
###

# Add executable permissions
chmod 755 "${JUSTFILE}"

if [ "${USE_VSI_COMMON}" = "1" ]; then
  chmod 755 "${WRAPFILE}"
fi

# Add .gitignore exceptions
if ! grep -q local.env .gitignore 2>/dev/null; then
  echo local.env >> .gitignore
fi
if ! grep -q local_post.env .gitignore 2>/dev/null; then
  echo local_post.env >> .gitignore
fi

# ****************************************************************************
# ****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****DONE****
# ****************************************************************************
uwecho "Done!


        To complete your git initialization:

        cd $(quote "${PROJECT_DIR}")"
if [ ! -e .git ]; then
  echo "git init ." >&3
fi

if [ "${USE_VSI_COMMON}" = "1" ]; then
  uwecho "git submodule add https://github.com/visionsystemsinc/vsi_common.git $(quote "${RELATIVE_PATH}")
          git submodule update --init --recursive
          pushd $(quote "${RELATIVE_PATH}")
          git remote set-url origin --push git@github.com:visionsystemsinc/vsi_common.git
          popd" >&3
  echo   "git add $(quote "${SETUPFILE}") $(quote "${WRAPFILE}") .gitmodules" >&3
fi

echo   "git add .gitignore README.md $(quote "${JUSTFILE}") $(quote "${PROJECT_NAME}").env" >&3

if [ "${USE_DOCKER}" = "1" ]; then
  echo "git add .gitattributes .dockerignore docker-compose.yml docker/${APP_NAME}.Dockerfile docker/${APP_NAME}_entrypoint.bsh" >&3
else
  echo "git add hi.cpp" >&3
fi
if [ "${USE_PIPENV}" = "1" ]; then
  echo "git add Pipfile Pipfile.lock" >&3
fi

echo "git commit -m 'Initial commit'"  >&3
uwecho "


        To use your new just:

        cd $(quote "${PROJECT_DIR}")"

if [ "${USE_VSI_COMMON}" = "1" ]; then
  echo "source $(quote "${SETUPFILE}")"
fi

uwecho "just help

        Get started with:"

if [ "${USE_DOCKER}" = "1" ]; then
  uwecho "just setup
          just run ${APP_NAME} bash"
else
  uwecho "just compile
          just run"
fi
