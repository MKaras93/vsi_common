#!/usr/bin/env false
#Source this script to access just functionality

#****d* just/DRYRUN
# NAME
#   DRYRUN -- Print out some commands instead of executing
# SYNOPSIS
#   ${DRYRUN} <command>
# PURPOSE
#   Key commands that can be echoed out instead of executing. This is conveniently
#   set for you using the -n/--dryrun argument. Default: <Null>
# AUTHOR
#   Andy Neff
# EXAMPLE
#   An example of wrapping a commonly used 
#   function Docker()
#   {
#     ${DRYRUN} docker "${@}"
#   }
# NOTES
#   DRYRUN doesn't just echo out the command, it uses the print_command function
#   to print out a command that can be copied and pasted in. The handles spaces
#   correctly unlike echo.
# SEE ALSO
#   just/print_command
#***
: ${DRYRUN=}
#****d* just/JUST_SEPARATOR
# NAME
#   JUST_SEPARATOR -- Separator used for get_args
# PURPOSE
#   When passing an unknown number of arguments, the JUST_SEPARATOR can be used
#   to begin and end a group of arguments . Default: --
# AUTHOR
#   Andy Neff
# SEE ALSO
#   just/get_args, just/get_additional_args
#***
: ${JUST_SEPARATOR='--'}
#****d* just/JUST_SAFE_LOAD_DELIMITER
# NAME
#   JUST_SAFE_LOAD_DELIMITER -- Separator used for safe_load
# PURPOSE
#   safe_load reads a key:value file, and this variable is used to seprate the
#   keys and values. Default: =
# AUTHOR
#   Andy Neff
# SEE ALSO
#   just/safe_load
#***
: ${JUST_SAFE_LOAD_DELIMITER='='}
#****id* just/JUST_HELP_SEPARATOR
# NAME
#   JUST_HELP_SEPARATOR -- Separator used internally for processing help comments
# PURPOSE
#   When processing the help comments, the JUST_HELP_SEPARATOR is used to 
#   separate the strings. As long as no help string contains this, everything
#   will work out. Default: @#@
# AUTHOR
#   Andy Neff
# BUGS
#   * If a comment contains " ${JUST_HELP_SEPARATOR} ", then it will be truncated
#     at the first instance
#   * If JUST_HELP_SEPARATOR is not regex safe, it will not work either. 
# SEE ALSO
#   just/safe_load
#***
: ${JUST_HELP_SEPARATOR='@#@'} #This pattern needs to be regex clean, or else bad things will happen

#This file
JUST_FUNCTIONS_FILE=${BASH_SOURCE[0]}

# A few functions are defines in a common. Sourced here for DRY
. "$(dirname "${BASH_SOURCE[0]}")/just_common.bsh"

# Preload some files
. "$(dirname "${BASH_SOURCE[0]}")/isin"

# list_cases()
# {
#   local indent=${indent-'^ +'}
#   local cmd_pattern=${cmd_pattern-'["a-z0-9]?["_a-z0-9| \-]*'}
#   local oldIFS="${IFS}"
#   IFS=''
#   IFS=$'\n' read -d '' -r -a case_list <<< $(grep -E "${indent}${cmd_pattern}\)" "$1" | sed -E 's|'"${indent}(${cmd_pattern})"'\).*|\1|') || :
#   IFS="${oldIFS}"
# }

function source_environment_files()
{
  local project_dir="$(dirname $1)"
  for file in "${project_dir}/local.env" \
              "$1" \
              "${project_dir}/local_post.env"; do
    if [ -f "$file" ]; then
      set -a
      . "${file}"
      set +a
    fi
  done
}


function load_justfile()
{
  JUSTFILE=$(_just_find_justfile "${1}")
  if [ -f "${JUSTFILE}" ]; then
    source "${JUSTFILE}"
  fi
}

# print_help_from_file()
# {
#   #grep -E '^ +[a-z0-9|\-]+\)|^ +[_a-z0-9|\-]+\) *#' "$1" | sed -E 's| *([0-9|_a-z-]*)\) *#? *(.*)|\1 --- \2|' \
#   # Look for all switch cases commands with a comment
#   grep -E '^ *#? ?[_a-z0-9|\-]+\) *#' "$1" | \
#   # Segment into "command JUST_HELP_SEPARATOR comment"
#   sed -E 's|^([^_]*)_(.*\))|\1 \2|;s|[ #]*([ _0-9|a-z-]*)\) *#? *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|' | \
#   # awk using ' JUST_HELP_SEPARATOR ' as the separator
#   awk -F " ${JUST_HELP_SEPARATOR} " '
#    { printf "%-'$(($indent-1))'s ", $1
#     n = split($2,x," ")
#     len = '${indent}'
#     for(i=1;i<=n;i++){
#      if(len+length(x[i])>='$(tput cols)'){printf("\n%'$indent's", ""); len = '${indent}'}
#      printf "%s ",x[i]
#      len += 1+length(x[i])
#     }
#     printf "\n"
#   }' #c/o http://unix.stackexchange.com/a/280205/123413
# }

function pretty_print_help()
{
  # awk using ' JUST_HELP_SEPARATOR ' as the separator
  awk -F " ${JUST_HELP_SEPARATOR} " '
   { printf "%-'$(($indent-1))'s ", $1
    n = split($2,x," ")
    len = '${indent}'
    for(i=1;i<=n;i++){
     if(len+length(x[i])>='$(tput cols)'){printf("\n%'$indent's", ""); len = '${indent}'}
     printf "%s ",x[i]
     len += 1+length(x[i])
    }
    printf "\n"
  }' #c/o http://unix.stackexchange.com/a/280205/123413
}

function parse_help_file()
{
  # Look for all switch cases commands with a comment
  grep -E '^ *#? ?[_a-z0-9|\-]+\) *#' "$1" |
          # Segment into "command JUST_HELP_SEPARATOR comment"
  sed -E 's|[ #]*([ _0-9|a-z-]*)\) *#? *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|
          :a #Label a
          ## Converts aaa|bbb|ccc @#@ blah to aaa @#@ blah\nbbb @#@ blah\n...
          s/\|(.* '"${JUST_HELP_SEPARATOR}"' (.*))/ '"${JUST_HELP_SEPARATOR}"' \2\n\1/
          t a' # Goto a if last line matched. Else done!
}

function print_subcommand_help()
{
  local just_subcommands=()
  _just_get_subcommands "${1}"

  if (( ${#just_subcommands[@]} )); then
    local i
    local j
    local just_subtargets
    for i in ${!just_subcommands[@]}; do
      echo "${just_subcommands[$i]}"
      just_subtargets=()
      _just_get_subtargets "${just_subcommands[$i]}" caseify
      for j in ${!just_subtargets[@]}; do
        echo "  ${just_subtargets[$j]}"
      done
    done
  fi
}

function print_help()
{
  local cols=$(tput cols)
  local indent=21
  local parsed_help parsed_help_flags parsed_help_subcommands_commented
  local parsed_help_a=()

  echo "List of possible $(basename "$0") commands:"
  echo "-----------------------------------"

  # Get help data
  parsed_help="$(parse_help_file "${JUSTFILE}")"$'\n'
  parsed_help+="$(parse_help_file "${JUST_FUNCTIONS_FILE}")"

  # Create an array copy
  IFS=$'\n' parsed_help_a=(${parsed_help})

  ### Split up flags and commands
  ###parsed_help_flags="$(grep ^- <<< "${parsed_help}")" || :
  ###parsed_help_subcommands_commented="$(grep -E '^[a-zA-Z0-9\-]+ [a-zA-Z0-9\-]+' <<< "${parsed_help}")" || :
  ###parsed_help="$(grep -E -v '^-|^[a-zA-Z0-9\-]+ [a-zA-Z0-9\-]+' <<< "${parsed_help}")" || :
  ###Since any one of these sets could be empty, add || : to eval true

  # Pretty print
  ###( sort | pretty_print_help ) <<< "${parsed_help}"
  # Print non-flag first and non-subcommand_subtargets
  ( grep -E -v '^-|^[a-zA-Z0-9\-]+_[a-zA-Z0-9_\-]+' | 
    sort | 
    pretty_print_help ) <<< "${parsed_help_a[*]}"

  # Print flags second
  ( grep -E '^-[a-zA-Z0-9\-]+( |$)' | sort | pretty_print_help ) <<< "${parsed_help_a[*]}"

  echo
  echo "Subcommands"
  echo "-----------"
  
  local just_subcommands=()
  local just_subtargets
  local subcommand
  local subtarget
  local parsed_help_subcommands=""
  local help_line

  _just_get_subcommands caseify
  # Sort the subcommands
  if [ "${just_subcommands+set}" == "set" ]; then
    IFS=$'\n' just_subcommands=($(sort <<<"${just_subcommands[*]}"))
  fi

  for subcommand in ${just_subcommands+"${just_subcommands[@]}"}; do
    parsed_help_subcommands+="${subcommand}"$'\n'
    
    # Get list of subtargets
    just_subtargets=()
    _just_get_subtargets "${subcommand}" caseify
    # Sort the subtargets
    if [ "${just_subtargets+set}" == "set" ]; then
      IFS=$'\n' just_subtargets=($(sort <<<"${just_subtargets[*]}"))
    fi

    for subtarget in ${just_subtargets+"${just_subtargets[@]}"}; do
      for help_line in "${parsed_help_a[@]}"; do 
        if [[ ${help_line} =~ ^${subcommand}_${subtarget}.* ]]; then 
          parsed_help_subcommands+="    ${help_line#*_}"$'\n'
          break
        fi
        help_line=
      done
      if [ "${help_line}" == "" ]; then
        parsed_help_subcommands+="    ${subtarget}"$'\n'
      fi
    done
  done

  pretty_print_help <<< "${parsed_help_subcommands%$'\n'}"
}

# print_help_old()
# {
#   echo "List of possible $(basename "$0") commands:"
#   echo "-----------------------------------"
#   cols=$(tput cols)
#   indent=21
#   #Only find lines with _ if there is a comment at the end.
#   print_help_from_file "${JUSTFILE}"
#   print_help_from_file "${JUST_FUNCTIONS_FILE}"
#   echo
#   echo "Subcommands"
#   echo "-----------"
#   print_subcommand_help caseify
# }

### powershell setup ###
# Cygwin bash is pretty bad. The new git bash (MINGW64) does not have a tty.
# This is pretty bad for docker. Powershell does have a tty, buy can not run
# bash scrips natively. The solution is to run bash in powershell. These functions
# help with that.

function is_powershell()
{
  if [ "${VSI_COMMON_IS_POWERSHELL-0}" == "1" ]; then
    return 0
  fi

  local unique_title=$(head -c 16 /dev/urandom | xxd -pu)
  echo -en "\033]0;${unique_title}\a"
  if [ $(tasklist //fi "windowtitle eq ${unique_title}" | tail -n 1 | awk '{print $1}') == "powershell.exe" ]; then
    return 0
  else
    return 1
  fi
}

function setup_powershell()
{ # Usage: setup_powershell ${@+"${@}"}
  # This is designed to rerun a script being called from. Do not call from command line
  if [ "${OS-notwindows}" == "Windows_NT" ] && ! is_powershell; then
    if [ "${#@}" == "0" ]; then
      setup_powershell _null
    else
      exec env VSI_COMMON_IS_POWERSHELL=1 start powershell "cmd /c color 07; bash \"$0\" ${@}; bash --rcfile \"${VSI_COMMON_DIR}/.winbashrc\""
    fi
  fi
}

function print_command()
{ 
  if command -v python >& /dev/null; then
    python -c "import pipes as p; import sys as s; print(' '.join([p.quote(x) for x in s.argv[1:]]))" "${@}"
  else
    #FAR from perfect... Need to escape " and not always print ''
    while [ "$#" -gt 0 ]; do
      printf \'"$1"\'
      shift 1
      [ "$#" -gt 0 ] && printf " "
    done
    printf "\n"
  fi
}

function defaultify()
{
  arg=$1
  shift 1
  case $arg in
    --dryrun|-n) #Dryrun flag. Used to echo instead of run commands
      export DRYRUN=print_command
      ;;
    --separator) #Commands that can take an undefined number of additional arguments use the -- separator to start and end the extra arguments. If you need -- for other things, specify a custom separator. For example "dustify build -- --build-arg=x=16 -- run" could become "dustify -separator xx build xx --build-arg=x=16 -- xx run"
      JUST_SEPARATOR=$1
      extra_args+=1
      ;;
    -h|--help|help) #Print help
      print_help
      ;;
    _null)
      ;;
    *)
      echo "I don't understand $arg"
      exit 1
      ;;
  esac
}

declare -i extra_args

function justify()
{ #caseify needs to be written by the main script, and set the number
  #of extra arguments it consumes to extra_args

  #Cache list of subcommands
  local just_subcommands=()
  _just_get_subcommands caseify
  local just_subtargets

  while (( $# > 0 )); do
    extra_args=0

    #If it's a subcommand
    if isin "${1}" ${just_subcommands+"${just_subcommands[@]}"}; then
      #Get list of targets for subcommand
      just_subtargets=()
      _just_get_subtargets "${1}" caseify

      #If it's a valid target, call them, else use default caseify
      if (( $# >= 2 )) && isin "${2}" ${just_subtargets+"${just_subtargets[@]}"}; then
        local target="${1}_"
        shift 1

        #execute all targets
        while (( $# > 0 )) && isin "${1}" ${just_subtargets+"${just_subtargets[@]}"}; do
          extra_args=0
          caseify "${target}${@}"
          shift $extra_args
          shift 1
        done
        continue
      else
        caseify "${@}"
      fi
    else
      caseify "${@}"
    fi
    shift $extra_args
    shift 1
  done
}

function find_in()
{
  #Find $1 in $2-n. Return 1 for $2, 2 for $3, etc... 0 for not found
  local val=$1
  local x
  shift 1
  for ((x=1; x<=${#@}; x++)); do
    if [ "${!x}" == "${val}" ]; then
      return ${x}
    fi
  done

  return 0
}

function callify()
{ # Takes: cmd -- $1 $2 $3 ... $n -- $m $m+1 ... 
  # and calls: cmd $1 $2 $3 ... $n and consumes n+2 args
  # Trailing -- is optional
  local cmd next_break
  cmd=$1
  shift 1
  get_args "${@}"
  $cmd ${args+"${args[@]}"}
}

function get_args() #Function used to consume a collection of arguments and store in args
{ # -- $2 $3 $4 ... $n -- $n+2, $n+3 ... Only capture $2-$n and consumes n+1 
  #(or $n if no trailing --)
  #stores in array "args"
  args=()
  : ${extra_args=0}
  args_used=${pre_args_used-0}
  if (( $# >= 1 )); then
    if [ "$1" == "${JUST_SEPARATOR}" ]; then
      shift 1
      next_break=0
      find_in "${JUST_SEPARATOR}" ${@+"${@}"} || next_break=$? #look to see if there is another --
      if [ "${next_break}" == 0 ]; then
        args_used=$((${args_used}+$#+1))
        extra_args+=$#+1
        args=("${@:1}")
      else
        args_used=$((${args_used}+${next_break}+1))
        args=("${@:1:$(($next_break-1))}")
        extra_args+=${next_break}+1
      fi
    else
      args=()
    fi
  fi
}

function get_additional_args()
{ # Must be called after get_args with all arguments passed in. For example:
  # get_args ${@+"${@}"}
  # args1=(${args+"${args[@]}"})
  # get_additional_args ${@+"${@}"}
  # args2=(${args+"${args[@]}"})
  # get_additional_args ${@+"${@}"}
  # ...

  local pre_args_used

  if [ "${args_used}" -gt "0" ]; then
    pre_args_used=$((${args_used}-1))
    shift ${pre_args_used} # Go back one arg wrt last args call
    extra_args+=-1         # to get the beginning --
    if [ "$1" == "${JUST_SEPARATOR}" ]; then # It should start with --. Use get_args as normal
      get_args "${@}"
    else # Else there is no --, and basically abort get_additional_args. 
      extra_args+=1
      args=()
    fi
  fi
}

function safe_load() #Loads a very simple safe config file, and sets environment variables accordingly
{ #File should contain lines: key=value
  local safe_load_tmp_key=foobar
  local safe_load_tmp_value
  while IFS='' read -r line || [[ -n "${line}" ]]; do
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key safe_load_tmp_value <<< "$line"
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key "$safe_load_tmp_key" <<< "$line"
    export "$safe_load_tmp_key"
  done < $1
}
