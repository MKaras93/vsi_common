#!/usr/bin/env false
#Source this script to access just functionality

#****d* just/DRYRUN
# NAME
#   DRYRUN -- Print out some commands instead of executing
# SYNOPSIS
#   ${DRYRUN} <command>
# PURPOSE
#   Key commands that can be echoed out instead of executing. This is conveniently
#   set for you using the -n/--dryrun argument. Default: <Null>
# AUTHOR
#   Andy Neff
# EXAMPLE
#   An example of wrapping a commonly used 
#   function Docker()
#   {
#     ${DRYRUN} docker "${@}"
#   }
# NOTES
#   DRYRUN doesn't just echo out the command, it uses the print_command function
#   to print out a command that can be copied and pasted in. The handles spaces
#   correctly unlike echo.
# SEE ALSO
#   just/print_command
#***
: ${DRYRUN=}
#****d* just/JUST_SEPARATOR
# NAME
#   JUST_SEPARATOR -- Separator used for get_args
# PURPOSE
#   When passing an unknown number of arguments, the JUST_SEPARATOR can be used
#   to begin and end a group of arguments . Default: --
# AUTHOR
#   Andy Neff
# SEE ALSO
#   just/get_args, just/get_additional_args
#***
: ${JUST_SEPARATOR='--'}
#****d* just/JUST_SAFE_LOAD_DELIMITER
# NAME
#   JUST_SAFE_LOAD_DELIMITER -- Separator used for safe_load
# PURPOSE
#   safe_load reads a key:value file, and this variable is used to seprate the
#   keys and values. Default: =
# AUTHOR
#   Andy Neff
# SEE ALSO
#   just/safe_load
#***
: ${JUST_SAFE_LOAD_DELIMITER='='}
#****id* just/JUST_HELP_SEPARATOR
# NAME
#   JUST_HELP_SEPARATOR -- Separator used internally for processing help comments
# PURPOSE
#   When processing the help comments, the JUST_HELP_SEPARATOR is used to 
#   separate the strings. As long as no help string contains this, everything
#   will work out. Default: @#@
# AUTHOR
#   Andy Neff
# BUGS
#   * If a comment contains " ${JUST_HELP_SEPARATOR} ", then it will be truncated
#     at the first instance
#   * If JUST_HELP_SEPARATOR is not regex safe, it will not work either. 
# SEE ALSO
#   just/safe_load
#***
: ${JUST_HELP_SEPARATOR='@#@'} #This pattern needs to be regex clean, or else bad things will happen

#****** just/plugin
# DESCRIPTION
#   To allow commonly used functionality to be added to the targets for just,
#   Add the case function names to the array JUST_DEFAULTIFY_FUNCTIONS
#
#   Must return non-zero if the argument is not used, and return 0 on consumption
#   of a variable
# EXAMPLE
#   Source just_example_functions.bsh, which should contain:
#
#   JUST_DEFAULTIFY_FUNCTIONS+=(just_example_defaultify)
#   JUST_HELP_FILES+=("${BASH_SOURCE[0]}")
#   function just_example_defaultify()
#   {
#     arg=$1
#     shift 1
#     case $arg in
#       foo|bar) :#Foobar test
#         echo "Foo or bar: $1"
#         extra_args+=1
#         ;;
#       *)
#         return 1
#         ;;
#     esac
#     return 0
#   }
# BUGS
#   Tab complete currently has no way of discovering which plugins are enabled.
#   To get around this, have whatever scipt you use to setup your environment
#   (typically: source setup.env), and add JUST_HELP_FILES=(<list of plugin files>)
#***

#****d* plugin/JUST_DEFAULTIFY_FUNCTIONS
# NAME
#   JUST_DEFAULTIFY_FUNCTIONS - List of defaultify functions
# DESCRIPTION
#   The values of this array are executed as a command. Each plugin should have
#   a unique name for the function, and is responsible for adding that function
#   name to JUST_DEFAULTIFY_FUNCTIONS
# AUTHOR
#   Andy Neff
#***
JUST_DEFAULTIFY_FUNCTIONS=()

#****d* plugin/JUST_HELP_FILES
# NAME
#   JUST_HELP_FILES - List of functions using in just
# DESCRIPTION
#   This should include just_functions.bsh, which ever Justfile is used, and
#   any plugins. The plugin is responsible for adding itself to this array.
# AUTHOR
#   Andy Neff#***
JUST_HELP_FILES=(${BASH_SOURCE[0]})

# A few functions are defines in a common. Sourced here for DRY
. "$(dirname "${BASH_SOURCE[0]}")/just_common.bsh"

# Preload some files
. "$(dirname "${BASH_SOURCE[0]}")/isin"

#****f* just/source_environment_files
# NAME
#   source_environment_files -- Convenience function for sourcing environments
# DESCRIPTION
#   The just system works be sourcing three environment files
#   1. First ${project_dir}/local.env. This file should never be added to version
#      control. It should contain customizations for that particular install
#   2. The project file. This file should ideally contain all the default values
#      necessary to run without any local.env settings. 
#   3. Last, ${project_dir}/local_post.env. This file should never be added to
#      version control. It is rarely used, but in situations where you need to
#      set the value of a variable based off of another variable. This is why
#      it is loaded last.
# INPUTS
#   $1 - The project environment filename
# NOTES
#   Certain exceptions make sense for not storing values in the project file,
#   such as credentials, encryption keys, etc... information that should not be
#   hardcoded.
#
#   Only require settings in local.env when it cannot be avoided. For example, 
#   sometimes its better to add default behavior of create keys if possible.
#   Such as using openssl to create ssl certs in a default location (that is 
#   ignored by version control)
# AUTHOR
#   Andy Neff
#***
function source_environment_files()
{
  local project_dir="$(dirname $1)"
  for file in "${project_dir}/local.env" \
              "$1" \
              "${project_dir}/local_post.env"; do
    if [ -f "$file" ]; then
      set -a
      . "${file}"
      set +a
    fi
  done
}

#****f* just/load_justfile
# NAME
#   load_justfile -- Convenience function for loading Justfile
# SYNOPSIS
#   Loads the Justfile if it exists
# INPUTS
#   $1 - The Justfile filename
# AUTHOR
#   Andy Neff
#***
function load_justfile()
{
  JUSTFILE=$(_just_find_justfile "${1}")
  if [ -f "${JUSTFILE}" ]; then
    JUST_HELP_FILES+=("${JUSTFILE}")
    source "${JUSTFILE}"
  fi
}

#****f* just/pretty_print_help
# NAME
#   pretty_print_help -- Restructures text to indented properly on wrap around
# DESCRIPTION
#   Each line consists of a command that will be printed on the left, and the 
#   indented description on the right. The description is wrapped around based
#   on tput cols.
# INPUTS
#   stdin - Each line is a entry in the pretty printout, separated by
#           JUST_HELP_SEPARATOR
# PARAMETERS
#   indent - How much the right side should be indented to make a uniform output
# EXAMPLE
#   --dryrun             Dryrun flag. Used to echo instead of run
#                        commands
# SEE ALSO
#   JUST_HELP_SEPARATOR
# AUTHOR
#   Andy Neff
#***
function pretty_print_help()
{
  awk -F " ${JUST_HELP_SEPARATOR} " '
   { printf "%-'$(($indent-1))'s ", $1
    n = split($2,x," ")
    len = '${indent}'
    for(i=1;i<=n;i++){
     if(len+length(x[i])>='$(tput cols)'){printf("\n%'$indent's", ""); len = '${indent}'}
     printf "%s ",x[i]
     len += 1+length(x[i])
    }
    printf "\n"
  }' #c/o http://unix.stackexchange.com/a/280205/123413
}


#****f* just/print_help
# NAME
#   print_help -- Prints the auto generated help info from Justfile
# AUTHOR
#   Andy Neff
#***
function print_help()
{
  local cols=$(tput cols)
  local indent=21
  local parsed_help parsed_help_flags parsed_help_subcommands_commented
  local parsed_help_a

  echo "List of possible $(basename "$0") commands:"
  echo "-----------------------------------"

  # Get help data => parsed_help_a
  _just_parse_helps

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # Print non-flag first and non-subcommand_subtargets
  ( grep -E -v '^-|^[a-zA-Z0-9\-]+_[a-zA-Z0-9_\-]+' |
    sort |
    pretty_print_help ) <<< "${parsed_help_a[*]}"

  # Print flags second
  ( grep -E '^-[a-zA-Z0-9\|\-]+( |$)' | sort | pretty_print_help ) <<< "${parsed_help_a[*]}"
  IFS="${OLD_IFS}"

  echo
  echo "Subcommands"
  echo "-----------"
  
  local just_subcommands=()
  local just_subtargets
  local subcommand
  local subtarget
  local parsed_help_subcommands=""
  local help_line

  IFS=$'\n'
  just_subcommands=($(_just_subcommands_from_array <<< "${parsed_help_a[*]}"))
  IFS="${OLD_IFS}"

  # Sort the subcommands
  if [ "${just_subcommands+set}" == "set" ]; then
    IFS=$'\n'
    just_subcommands=($(sort -u <<<"${just_subcommands[*]}"))
    IFS="${OLD_IFS}"
  fi

  for subcommand in ${just_subcommands+"${just_subcommands[@]}"}; do
    parsed_help_subcommands+="${subcommand}"$'\n'
    
    # Get list of subtargets
    just_subtargets=()
    # Get all the subtargets already parsed by the helpfile
    _just_subtargets_from_array "${subcommand}" ${parsed_help_a+"${parsed_help_a[@]}"}

    # Sort the subtargets
    if [ "${just_subtargets+set}" == "set" ]; then
      IFS=$'\n'
      just_subtargets=($(sort -u <<<"${just_subtargets[*]}"))
      IFS="${OLD_IFS}"
    fi

    for subtarget in ${just_subtargets+"${just_subtargets[@]}"}; do

      for help_line in "${parsed_help_a[@]}"; do 
        if [[ ${help_line} =~ ^${subcommand}_${subtarget}.* ]]; then 
          parsed_help_subcommands+="    ${help_line#*_}"$'\n'
          break
        fi
        help_line=
      done
      if [ "${help_line}" == "" ]; then
        parsed_help_subcommands+="    ${subtarget}"$'\n'
      fi
    done
  done

  pretty_print_help <<< "${parsed_help_subcommands%$'\n'}"
}

### powershell setup ###
# Cygwin bash is pretty bad. The new git bash (MINGW64) does not have a tty.
# This is pretty bad for docker. Powershell does have a tty, buy can not run
# bash scrips natively. The solution is to run bash in powershell. These functions
# help with that.

#****f* just/is_powershell
# NAME
#   is_powershell -- Check if the current command windows is powershell
# SYNOPSIS
#   Using a Window title trick, determine if you are running in powershell, or 
#   not, for example command prompt windows, cygwin or git bash
# AUTHOR
#   Andy Neff
#***
function is_powershell()
{
  if [ "${VSI_COMMON_IS_POWERSHELL-0}" == "1" ]; then
    return 0
  fi

  local unique_title=$(head -c 16 /dev/urandom | xxd -pu)
  echo -en "\033]0;${unique_title}\a"
  if [ $(tasklist //fi "windowtitle eq ${unique_title}" | tail -n 1 | awk '{print $1}') == "powershell.exe" ]; then
    return 0
  else
    return 1
  fi
}

#****f* just/setup_powershell
# NAME
#   setup_powershell -- Pops up a new powershell window and runs just
# SYNOPSIS
#   This is designed to rerun a script being called from
# USAGE
#   setup_powershell ${@+"${@}"}
# AUTHOR
#   Andy Neff
#***
function setup_powershell()
{ 
  if [ "${OS-notwindows}" == "Windows_NT" ] && ! is_powershell; then
    if [ "${#@}" == "0" ]; then
      setup_powershell _null
    else
      exec env VSI_COMMON_IS_POWERSHELL=1 start powershell "cmd /c color 07; bash \"$0\" ${@}; bash --rcfile \"${VSI_COMMON_DIR}/.winbashrc\""
    fi
  fi
}

#****f* just/print_command
# NAME
#   print_command -- Echo out a command
# SYNOPSIS
#   If python is available, accurately echoes out a properly escaped
#   representation of the arguments. Else, it echoes out an approximation just
#   adding quotes
# BUGS
#   If python is not available, arguments with ' in them will not be printed out
#   perfectly
# AUTHOR
#   Andy Neff
#***
function print_command()
{ 
  if command -v python >& /dev/null; then
    python -c "import pipes as p; import sys as s; print(' '.join([p.quote(x) for x in s.argv[1:]]))" "${@}"
  else
    #FAR from perfect... Need to escape " and not always print ''
    while [ "$#" -gt 0 ]; do
      printf \'"$1"\'
      shift 1
      [ "$#" -gt 0 ] && printf " "
    done
    printf "\n"
  fi
}

function defaultify()
{
  local arg
  # Loop through the plugins, and call them
  for arg in ${JUST_DEFAULTIFY_FUNCTIONS+"${JUST_DEFAULTIFY_FUNCTIONS[@]}"}; do
    if ${arg} ${@+"${@}"};  then
      return
    fi
  done

  arg=$1
  shift 1
  case $arg in
    --dryrun|-n) #Dryrun flag. Used to echo instead of run commands
      export DRYRUN=print_command
      ;;
    --separator) #Commands that can take an undefined number of additional arguments use the -- separator to start and end the extra arguments. If you need -- for other things, specify a custom separator
      JUST_SEPARATOR=$1
      extra_args+=1
      ;;
    -h|--help|help) #Print help
      print_help
      ;;
    _null)
      ;;
    *)
      echo "I don't understand $arg"
      exit 1
      ;;
  esac
}

declare -i extra_args

function justify()
{ #caseify needs to be written by the main script, and set the number
  #of extra arguments it consumes to extra_args

  #Cache list of subcommands
  local just_subcommands=()
  local just_subtargets

  local parsed_help_a
  # Get help data => parsed_help_a
  _just_parse_helps

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  just_subcommands=($(_just_subcommands_from_array <<< "${parsed_help_a[*]}"))
  IFS="${OLD_IFS}"

  while (( $# > 0 )); do
    extra_args=0

    #If it's a subcommand
    if isin "${1}" ${just_subcommands+"${just_subcommands[@]}"}; then
      just_subtargets=()
      #Get all the subtargets already parsed by the helpfile
      _just_subtargets_from_array "${1}" ${parsed_help_a+"${parsed_help_a[@]}"}

      #If it's a valid target, call them, else use default caseify
      if (( $# >= 2 )) && isin "${2}" ${just_subtargets+"${just_subtargets[@]}"}; then
        local target="${1}_"
        shift 1

        #execute all targets
        while (( $# > 0 )) && isin "${1}" ${just_subtargets+"${just_subtargets[@]}"}; do
          extra_args=0
          caseify "${target}${@}"
          shift $extra_args
          shift 1
        done
        continue
      else
        caseify "${@}"
      fi
    else
      caseify "${@}"
    fi
    shift $extra_args
    shift 1
  done
}

function find_in()
{
  #Find $1 in $2-n. Return 1 for $2, 2 for $3, etc... 0 for not found
  local val=$1
  local x
  shift 1
  for ((x=1; x<=${#@}; x++)); do
    if [ "${!x}" == "${val}" ]; then
      return ${x}
    fi
  done

  return 0
}

function callify()
{ # Takes: cmd -- $1 $2 $3 ... $n -- $m $m+1 ... 
  # and calls: cmd $1 $2 $3 ... $n and consumes n+2 args
  # Trailing -- is optional
  local cmd next_break
  cmd=$1
  shift 1
  get_args "${@}"
  $cmd ${args+"${args[@]}"}
}

function get_args() #Function used to consume a collection of arguments and store in args
{ # -- $2 $3 $4 ... $n -- $n+2, $n+3 ... Only capture $2-$n and consumes n+1 
  #(or $n if no trailing --)
  #stores in array "args"
  args=()
  : ${extra_args=0}
  args_used=${pre_args_used-0}
  if (( $# >= 1 )); then
    if [ "$1" == "${JUST_SEPARATOR}" ]; then
      shift 1
      next_break=0
      find_in "${JUST_SEPARATOR}" ${@+"${@}"} || next_break=$? #look to see if there is another --
      if [ "${next_break}" == 0 ]; then
        args_used=$((${args_used}+$#+1))
        extra_args+=$#+1
        args=("${@:1}")
      else
        args_used=$((${args_used}+${next_break}+1))
        args=("${@:1:$(($next_break-1))}")
        extra_args+=${next_break}+1
      fi
    else
      args=()
    fi
  fi
}

function get_additional_args()
{ # Must be called after get_args with all arguments passed in. For example:
  # get_args ${@+"${@}"}
  # args1=(${args+"${args[@]}"})
  # get_additional_args ${@+"${@}"}
  # args2=(${args+"${args[@]}"})
  # get_additional_args ${@+"${@}"}
  # ...

  local pre_args_used

  if [ "${args_used}" -gt "0" ]; then
    pre_args_used=$((${args_used}-1))
    shift ${pre_args_used} # Go back one arg wrt last args call
    extra_args+=-1         # to get the beginning --
    if [ "$1" == "${JUST_SEPARATOR}" ]; then # It should start with --. Use get_args as normal
      get_args "${@}"
    else # Else there is no --, and basically abort get_additional_args. 
      extra_args+=1
      args=()
    fi
  fi
}

function safe_load() #Loads a very simple safe config file, and sets environment variables accordingly
{ #File should contain lines: key=value
  local safe_load_tmp_key=foobar
  local safe_load_tmp_value
  while IFS='' read -r line || [[ -n "${line}" ]]; do
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key safe_load_tmp_value <<< "$line"
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key "$safe_load_tmp_key" <<< "$line"
    export "$safe_load_tmp_key"
  done < $1
}
