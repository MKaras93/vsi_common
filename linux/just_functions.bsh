#!/usr/bin/env false
#Source this script for

: ${DRYRUN=}
: ${JUST_SEPARATOR='--'}
: ${JUST_SAFE_LOAD_DELIMITER='='}
: ${JUST_HELP_SEPARATOR='@#@'}

JUST_FUNCTIONS_FILE=${BASH_SOURCE[0]}

# A few functions are defines in .just for auto-complete. Sourced here for DRY
. "$(dirname "${BASH_SOURCE[0]}")/just_common.bsh"

# list_cases()
# {
#   local indent=${indent-'^ +'}
#   local cmd_pattern=${cmd_pattern-'["a-z0-9]?["_a-z0-9| \-]*'}
#   local oldIFS="${IFS}"
#   IFS=''
#   IFS=$'\n' read -d '' -r -a case_list <<< $(grep -E "${indent}${cmd_pattern}\)" "$1" | sed -E 's|'"${indent}(${cmd_pattern})"'\).*|\1|') || :
#   IFS="${oldIFS}"
# }

source_environment_files()
{
  local project_dir="$(dirname $1)"
  for file in "${project_dir}/local.env" \
              "$1" \
              "${project_dir}/local_post.env"; do
    if [ -f "$file" ]; then
      set -a
      . "${file}"
      set +a
    fi
  done
}

load_justfile()
{
  JUSTFILE=$(_just_find_justfile "${1}")
  if [ -f "${JUSTFILE}" ]; then
    export JUST_DIR="$(dirname "${JUSTFILE}")"
    source "${JUSTFILE}"
  fi
}

print_help_from_file()
{
  #grep -E '^ +[a-z0-9|\-]+\)|^ +[_a-z0-9|\-]+\) *#' "$1" | sed -E 's| *([0-9|_a-z-]*)\) *#? *(.*)|\1 --- \2|' \
  # Look for all switch cases commands with a comment
  grep -E '^ *#? ?[_a-z0-9|\-]+\) *#' "$1" | \
  # Segment into "command JUST_HELP_SEPARATOR comment"
  sed -E 's|^([^_]*)_(.*\))|\1 \2|;s|[ #]*([ _0-9|a-z-]*)\) *#? *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|' | \
  # awk using ' JUST_HELP_SEPARATOR ' as the separator
  awk -F " ${JUST_HELP_SEPARATOR} " '
   { printf "%-'$(($indent-1))'s ", $1
    n = split($2,x," ")
    len = '${indent}'
    for(i=1;i<=n;i++){
     if(len+length(x[i])>='$(tput cols)'){printf("\n%'$indent's", ""); len = '${indent}'}
     printf "%s ",x[i]
     len += 1+length(x[i])
    }
    printf "\n"
  }' #c/o http://unix.stackexchange.com/a/280205/123413
}

pretty_print_help()
{
  # awk using ' JUST_HELP_SEPARATOR ' as the separator
  awk -F " ${JUST_HELP_SEPARATOR} " '
   { printf "%-'$(($indent-1))'s ", $1
    n = split($2,x," ")
    len = '${indent}'
    for(i=1;i<=n;i++){
     if(len+length(x[i])>='$(tput cols)'){printf("\n%'$indent's", ""); len = '${indent}'}
     printf "%s ",x[i]
     len += 1+length(x[i])
    }
    printf "\n"
  }'
}

parse_help_file()
{
  # Look for all switch cases commands with a comment
  grep -E '^ *#? ?[_a-z0-9|\-]+\) *#' "$1" |
          # Segment into "command JUST_HELP_SEPARATOR comment"
  sed -E 's|[ #]*([ _0-9|a-z-]*)\) *#? *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|
          :a #Label a
          ## Converts aaa|bbb|ccc @#@ blah to aaa @#@ blah\nbbb @#@ blah\n...
          s/\|(.* '"${JUST_HELP_SEPARATOR}"' (.*))/ '"${JUST_HELP_SEPARATOR}"' \2\n\1/
          t a' # Goto a if last line matched. Else done!
}

print_subcommand_help()
{
  local just_subcommands=()
  _just_get_subcommands "${1}"

  if (( ${#just_subcommands[@]} )); then
    local i
    local j
    local just_subtargets
    for i in ${!just_subcommands[@]}; do
      echo "${just_subcommands[$i]}"
      just_subtargets=()
      _just_get_subtargets "${just_subcommands[$i]}" caseify
      for j in ${!just_subtargets[@]}; do
        echo "  ${just_subtargets[$j]}"
      done
    done
  fi
}

print_help()
{
  local cols=$(tput cols)
  local indent=21
  local parsed_help parsed_help_flags parsed_help_subcommands_commented
  local parsed_help_a=()

  echo "List of possible $(basename "$0") commands:"
  echo "-----------------------------------"

  # Get help data
  parsed_help="$(parse_help_file "${JUSTFILE}")"
###  echo "$parsed_help"
  parsed_help+="$(parse_help_file "${JUST_FUNCTIONS_FILE}")"

  # Create an array copy
  IFS=$'\n' parsed_help_a=(${parsed_help})

  ### Split up flags and commands
  ###parsed_help_flags="$(grep ^- <<< "${parsed_help}")" || :
  ###parsed_help_subcommands_commented="$(grep -E '^[a-zA-Z0-9\-]+ [a-zA-Z0-9\-]+' <<< "${parsed_help}")" || :
  ###parsed_help="$(grep -E -v '^-|^[a-zA-Z0-9\-]+ [a-zA-Z0-9\-]+' <<< "${parsed_help}")" || :
  ###Since any one of these sets could be empty, add || : to eval true

  # Pretty print
  ###( sort | pretty_print_help ) <<< "${parsed_help}"
  # Print non-flag first and non-subcommand_subtargets
  ( grep -E -v '^-|^[a-zA-Z0-9\-]+_[a-zA-Z0-9_\-]+' | 
    sort | 
    pretty_print_help ) <<< "${parsed_help_a[*]}"

  # Print flags second
  ( grep -E '^-[a-zA-Z0-9\-]+( |$)' | sort | pretty_print_help ) <<< "${parsed_help_a[*]}"

  echo
  echo "Subcommands"
  echo "-----------"
  
  local just_subcommands=()
  local just_subtargets
  local subcommand
  local subtarget
  local parsed_help_subcommands=""

declare -p just_subcommands
  _just_get_subcommands caseify
  # Sort the subcommands
declare -p just_subcommands
  if [ "${just_subcommands+set}" == "set" ]; then
    IFS=$'\n' just_subcommands=($(sort <<<"${just_subcommands[*]}"))
  fi

declare -p just_subcommands
  for subcommand in ${just_subcommands+"${just_subcommands[@]}"}; do
    parsed_help_subcommands+="${subcommand}"$'\n'
    
    # Get list of subtargets
    just_subtargets=()
    _just_get_subtargets "${subcommand}" caseify
    # Sort the subtargets
    if [ "${just_subtargets+set}" == "set" ]; then
      IFS=$'\n' just_subtargets=($(sort <<<"${just_subtargets[*]}"))
    fi

    for subtarget in ${just_subtargets+"${just_subtargets[@]}"}; do

      parsed_help_subcommands+="    ${subtarget}"$'\n'
    done
  done

  (grep -v '^$' | pretty_print_help ) <<< "${parsed_help_subcommands}"
  echo ----
  ### pretty_print_help <<< "${parsed_help_subcommands_commented}"

}

print_help_old()
{
  echo "List of possible $(basename "$0") commands:"
  echo "-----------------------------------"
  cols=$(tput cols)
  indent=21
  #Only find lines with _ if there is a comment at the end.
  print_help_from_file "${JUSTFILE}"
  print_help_from_file "${JUST_FUNCTIONS_FILE}"
  echo
  echo "Subcommands"
  echo "-----------"
  print_subcommand_help caseify
}

print_command()
{ 
  if command -v python >& /dev/null; then
    python -c "import pipes as p; import sys as s; print(' '.join([p.quote(x) for x in s.argv[1:]]))" "${@}"
  else
    #FAR from perfect... Need to escape " and not always print ''
    while [ "$#" -gt 0 ]; do
      printf \'"$1"\'
      shift 1
      [ "$#" -gt 0 ] && printf " "
    done
    printf "\n"
  fi
}

defaultify()
{
  arg=$1
  shift 1
  case $arg in
    --dryrun|-n) #Dryrun flag. Used to echo instead of run commands
      export DRYRUN=print_command
      ;;
    --separator) #Commands that can take an undefined number of additional arguments use the -- separator to start and end the extra arguments. If you need -- for other things, specify a custom separator. For example "dustify build -- --build-arg=x=16 -- run" could become "dustify -separator xx build xx --build-arg=x=16 -- xx run"
      JUST_SEPARATOR=$1
      extra_args+=1
      ;;
    -h|--help|help) #Print help
      print_help
      ;;
    *)
      echo "I don't understand $arg"
      exit 1
      ;;
  esac
}

declare -i extra_args

justify()
{ #caseify needs to be written by the main script, and set the number
  #of extra arguments it consumes to extra_args

  #Cache list of subcommands
  local just_subcommands=()
  _just_get_subcommands caseify
  local just_subtargets

  while (( $# > 0 )); do
    extra_args=0

    #If it's a subcommand
    if isin "${1}" ${just_subcommands+"${just_subcommands[@]}"}; then
      #Get list of targets for subcommand
      just_subtargets=()
      _just_get_subtargets "${1}" caseify

      #If it's a valid target, call them, else use default caseify
      if (( $# >= 2 )) && isin "${2}" ${just_subtargets+"${just_subtargets[@]}"}; then
        local target="${1}_"
        shift 1

        #execute all targets
        while (( $# > 0 )) && isin "${1}" ${just_subtargets+"${just_subtargets[@]}"}; do
          extra_args=0
          caseify "${target}${@}"
          shift $extra_args
          shift 1
        done
        continue
      else
        caseify "${@}"
      fi
    else
      caseify "${@}"
    fi
    shift $extra_args
    shift 1
  done
}

find_in()
{
  #Find $1 in $2-n. Return 1 for $2, 2 for $3, etc... 0 for not found
  local val=$1
  local x
  shift 1
  for x in $(seq 1 "${#@}"); do
    if [ "${!x}" == "${val}" ]; then
      return ${x}
    fi
  done

  return 0
}

callify()
{ # Takes: cmd -- $1 $2 $3 ... $n -- $m $m+1 ... 
  # and calls: cmd $1 $2 $3 ... $n and consumes n+2 args
  # Trailing -- is optional
  local cmd next_break
  cmd=$1
  shift 1
  get_args "${@}"
  $cmd ${args+"${args[@]}"}
}

get_args() #Function used to consume a collection of arguments and store in args
{ # -- $2 $3 $4 ... $n -- $n+2, $n+3 ... Only capture $2-$n and consumes n+1 
  #(or $n if no trailing --)
  #stores in array "args"
  args=()
  : ${extra_args=0}
  args_used=${pre_args_used-0}
  if (( $# >= 1 )); then
    if [ "$1" == "${JUST_SEPARATOR}" ]; then
      shift 1
      next_break=0
      find_in "${JUST_SEPARATOR}" ${@+"${@}"} || next_break=$? #look to see if there is another --
      if [ "${next_break}" == 0 ]; then
        args_used=$((${args_used}+$#+1))
        extra_args+=$#+1
        args=("${@:1}")
      else
        args_used=$((${args_used}+${next_break}+1))
        args=("${@:1:$(($next_break-1))}")
        extra_args+=${next_break}+1
      fi
    else
      args=()
    fi
  fi
}

get_additional_args()
{ # Must be called after get_args with all arguments passed in. For example:
  # get_args ${@+"${@}"}
  # args1=(${args+"${args[@]}"})
  # get_additional_args ${@+"${@}"}
  # args2=(${args+"${args[@]}"})
  # get_additional_args ${@+"${@}"}
  # ...

  local pre_args_used

  if [ "${args_used}" -gt "0" ]; then
    pre_args_used=$((${args_used}-1))
    shift ${pre_args_used} # Go back one arg wrt last args call
    extra_args+=-1         # to get the beginning --
    if [ "$1" == "${JUST_SEPARATOR}" ]; then # It should start with --. Use get_args as normal
      pre_args_used=${pre_args_used} get_args "${@}"
    else # Else there is no --, and basically abort get_additional_args. 
      extra_args+=1
      args=()
    fi
  fi
}

safe_load_old() #Loads a very simple safe config file, and sets environment variables accordingly
{ #File should alternate lines: variable name, value. 
  local key=foobar
  while : ; do
    IFS='' read -r key || return 0
    IFS='' read -r $key || :
    export $key
    #echo $key is ${!key}
  done < $1
}

safe_load() #Loads a very simple safe config file, and sets environment variables accordingly
{ #File should contain lines: key=value
  local safe_load_tmp_key=foobar
  local safe_load_tmp_value
  while IFS='' read -r line || [[ -n "${line}" ]]; do
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key safe_load_tmp_value <<< "$line"
    IFS="${JUST_SAFE_LOAD_DELIMITER}" read -r safe_load_tmp_key "$safe_load_tmp_key" <<< "$line"
    export "$safe_load_tmp_key"
  done < $1
}


choseify()
{
  :
}
